// This file was automatically generated by IPG
// DO NOT EDIT!
#include "PEGParser.h"

using namespace PEGParser;

namespace
{
	typedef PTNodeTypeToPtr::value_type MemoEntry;
	typedef std::pair<PTNodeTypeToPtr::iterator, bool> MemoInsertResult;

	struct Private
	{
		static Node* Parse_AND(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_AND, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '&') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_CLOSE(Node* p0)
		{
			Node* p1 = (p0->value == ')') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			return p1;
		}

		static Node* Parse_Char(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Char, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\\') ? p0+1 : 0;
			if (p1)
			{
				Node* p2 = (p1->value == 'n') ? p1+1 : 0;
				if (!p2)
				{
					p2 = (p1->value == 'r') ? p1+1 : 0;
					if (!p2)
					{
						p2 = (p1->value == 't') ? p1+1 : 0;
						if (!p2)
						{
							p2 = (p1->value == '\'') ? p1+1 : 0;
							if (!p2)
							{
								p2 = (p1->value == '\"') ? p1+1 : 0;
								if (!p2)
								{
									p2 = (p1->value == '[') ? p1+1 : 0;
									if (!p2)
									{
										p2 = (p1->value == ']') ? p1+1 : 0;
										if (!p2)
										{
											p2 = (p1->value == '\\') ? p1+1 : 0;
											if (!p2)
											{
												p2 = (p1->value >= '1' && p1->value <= '9') ? p1+1 : 0;
												if (p2)
												{
													for (;;)
													{
														Node* p3 = (p2->value >= '0' && p2->value <= '9') ? p2+1 : 0;
														if (!p3)
															break;
														p2 = p3;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				p1 = p2;
			}
			if (!p1)
			{
				p1 = (p0->value == '\\') ? p0+1 : 0;
				p1 = p1 ? 0 : p0;
				if (p1)
				{
					p1 = (p1->value != 0) ? p1+1 : 0;
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Class(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Class, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '[') ? p0+1 : 0;
			if (p1)
			{
				for (;;)
				{
					Node* p2 = Parse_Class_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = (p1->value == ']') ? p1+1 : 0;
					if (p1)
					{
						p1 = Parse_Spacing(p1);
					}
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Class_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Class_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == ']') ? p0+1 : 0;
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Parse_Range(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Comment(Node* p0)
		{
			Node* p1 = (p0->value == '#') ? p0+1 : 0;
			if (p1)
			{
				for (;;)
				{
					Node* p2 = Parse_EndOfLine(p1);
					p2 = p2 ? 0 : p1;
					if (p2)
					{
						p2 = (p2->value != 0) ? p2+1 : 0;
					}
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = Parse_EndOfLine(p1);
				}
			}
			return p1;
		}

		static Node* Parse_DOT(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_DOT, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '.') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Definition(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Definition, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Identifier(p0);
			if (p1)
			{
				p1 = Parse_Spacing(p1);
				if (p1)
				{
					p1 = Parse_LEFTARROW(p1);
					if (p1)
					{
						p1 = Parse_Expression(p1);
					}
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_EndOfFile(Node* p0)
		{
			Node* p1 = (p0->value != 0) ? p0+1 : 0;
			p1 = p1 ? 0 : p0;
			return p1;
		}

		static Node* Parse_EndOfLine(Node* p0)
		{
			Node* p1 = (p0->value == '\r') ? p0+1 : 0;
			if (p1)
			{
				p1 = (p1->value == '\n') ? p1+1 : 0;
			}
			if (!p1)
			{
				p1 = (p0->value == '\n') ? p0+1 : 0;
				if (!p1)
				{
					p1 = (p0->value == '\r') ? p0+1 : 0;
				}
			}
			return p1;
		}

		static Node* Parse_Expression(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Expression, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Sequence(p0);
			if (p1)
			{
				for (;;)
				{
					Node* p2 = Parse_Expression_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Expression_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Expression_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_SLASH(p0);
			if (p1)
			{
				p1 = Parse_Sequence(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Grammar(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Grammar, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Spacing(p0);
			if (p1)
			{
				p1 = Parse_Definition(p1);
				if (p1)
				{
					for (;;)
					{
						Node* p2 = Parse_Definition(p1);
						if (!p2)
							break;
						p1 = p2;
					}
					if (p1)
					{
						p1 = Parse_EndOfFile(p1);
					}
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Identifier(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Identifier, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value >= 'a' && p0->value <= 'z') ? p0+1 : 0;
			if (!p1)
			{
				p1 = (p0->value >= 'A' && p0->value <= 'Z') ? p0+1 : 0;
				if (!p1)
				{
					p1 = (p0->value == '_') ? p0+1 : 0;
				}
			}
			if (p1)
			{
				for (;;)
				{
					Node* p2 = (p1->value >= 'a' && p1->value <= 'z') ? p1+1 : 0;
					if (!p2)
					{
						p2 = (p1->value >= 'A' && p1->value <= 'Z') ? p1+1 : 0;
						if (!p2)
						{
							p2 = (p1->value >= '0' && p1->value <= '9') ? p1+1 : 0;
							if (!p2)
							{
								p2 = (p1->value == '_') ? p1+1 : 0;
							}
						}
					}
					if (!p2)
						break;
					p1 = p2;
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_LEFTARROW(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_LEFTARROW, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '<') ? p0+1 : 0;
			if (p1)
			{
				Node* p2 = (p1->value == '-') ? p1+1 : 0;
				if (!p2)
				{
					p2 = (p1->value == '=') ? p1+1 : 0;
					if (!p2)
					{
						p2 = (p1->value == '<') ? p1+1 : 0;
					}
				}
				if (p2)
				{
					p2 = Parse_Spacing(p2);
				}
				p1 = p2;
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Literal(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Literal_1(p0);
			if (!p1)
			{
				p1 = Parse_Literal_2(p0);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Literal_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\'') ? p0+1 : 0;
			if (p1)
			{
				for (;;)
				{
					Node* p2 = Parse_Literal_1_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = (p1->value == '\'') ? p1+1 : 0;
					if (p1)
					{
						p1 = Parse_Spacing(p1);
					}
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Literal_1_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_1_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\'') ? p0+1 : 0;
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Parse_Char(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Literal_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_2, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\"') ? p0+1 : 0;
			if (p1)
			{
				for (;;)
				{
					Node* p2 = Parse_Literal_2_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = (p1->value == '\"') ? p1+1 : 0;
					if (p1)
					{
						p1 = Parse_Spacing(p1);
					}
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Literal_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_2_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\"') ? p0+1 : 0;
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Parse_Char(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_NOT(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_NOT, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '!') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_OPEN(Node* p0)
		{
			Node* p1 = (p0->value == '(') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			return p1;
		}

		static Node* Parse_PLUS(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_PLUS, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '+') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Prefix(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Prefix, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_AND(p0);
			if (!p1)
			{
				p1 = Parse_NOT(p0);
				if (!p1)
				{
					p1 = p0;
				}
			}
			if (p1)
			{
				p1 = Parse_Suffix(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Primary_1(p0);
			if (!p1)
			{
				p1 = Parse_Primary_2(p0);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Identifier(p0);
			if (p1)
			{
				p1 = Parse_Spacing(p1);
				if (p1)
				{
					Node* p2 = Parse_LEFTARROW(p1);
					p1 = p2 ? 0 : p1;
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Primary_2_1(p0);
			if (!p1)
			{
				p1 = Parse_Primary_2_2(p0);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_OPEN(p0);
			if (p1)
			{
				p1 = Parse_Expression(p1);
				if (p1)
				{
					p1 = Parse_CLOSE(p1);
				}
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary_2_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_2, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Literal(p0);
			if (!p1)
			{
				p1 = Parse_Primary_2_2_1(p0);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Primary_2_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_2_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Class(p0);
			if (!p1)
			{
				p1 = Parse_DOT(p0);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_QUESTION(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_QUESTION, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '?') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Range(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Range, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Char(p0);
			if (p1)
			{
				Node* p2 = Parse_Range_1(p1);
				if (!p2)
				{
					p2 = p1;
				}
				p1 = p2;
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Range_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Range_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '-') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Char(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_SLASH(Node* p0)
		{
			Node* p1 = (p0->value == '/') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			return p1;
		}

		static Node* Parse_STAR(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_STAR, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '*') ? p0+1 : 0;
			if (p1)
			{
				p1 = Parse_Spacing(p1);
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Sequence(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Sequence, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			for (;;)
			{
				Node* p2 = Parse_Prefix(p1);
				if (!p2)
					break;
				p1 = p2;
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Space(Node* p0)
		{
			Node* p1 = (p0->value == ' ') ? p0+1 : 0;
			if (!p1)
			{
				p1 = (p0->value == '\t') ? p0+1 : 0;
				if (!p1)
				{
					p1 = Parse_EndOfLine(p0);
				}
			}
			return p1;
		}

		static Node* Parse_Spacing(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Spacing, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			for (;;)
			{
				Node* p2 = Parse_Space(p1);
				if (!p2)
				{
					p2 = Parse_Comment(p1);
				}
				if (!p2)
					break;
				p1 = p2;
			}
			r.first->second = p1;
			return p1;
		}

		static Node* Parse_Suffix(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Suffix, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = Parse_Primary(p0);
			if (p1)
			{
				Node* p2 = Parse_QUESTION(p1);
				if (!p2)
				{
					p2 = Parse_STAR(p1);
					if (!p2)
					{
						p2 = Parse_PLUS(p1);
						if (!p2)
						{
							p2 = p1;
						}
					}
				}
				p1 = p2;
			}
			r.first->second = p1;
			return p1;
		}
		
		static Node* Traverse_AND(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_AND(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '&') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_CLOSE(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_CLOSE(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == ')') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_Char(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Char(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\\') ? p0+1 : 0;
			if (p2)
			{
				Node* p3 = (p2->value == 'n') ? p2+1 : 0;
				if (!p3)
				{
					p3 = (p2->value == 'r') ? p2+1 : 0;
					if (!p3)
					{
						p3 = (p2->value == 't') ? p2+1 : 0;
						if (!p3)
						{
							p3 = (p2->value == '\'') ? p2+1 : 0;
							if (!p3)
							{
								p3 = (p2->value == '\"') ? p2+1 : 0;
								if (!p3)
								{
									p3 = (p2->value == '[') ? p2+1 : 0;
									if (!p3)
									{
										p3 = (p2->value == ']') ? p2+1 : 0;
										if (!p3)
										{
											p3 = (p2->value == '\\') ? p2+1 : 0;
											if (!p3)
											{
												p3 = (p2->value >= '1' && p2->value <= '9') ? p2+1 : 0;
												if (p3)
												{
													for (;;)
													{
														Node* p4 = (p3->value >= '0' && p3->value <= '9') ? p3+1 : 0;
														if (!p4)
															break;
														p3 = p4;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				p2 = p3;
			}
			if (!p2)
			{
				p2 = (p0->value == '\\') ? p0+1 : 0;
				p2 = p2 ? 0 : p0;
				if (p2)
				{
					p2 = (p2->value != 0) ? p2+1 : 0;
				}
			}
			return p1;
		}

		static Node* Traverse_Class(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Class(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '[') ? p0+1 : 0;
			if (p2)
			{
				for (;;)
				{
					Node* p3 = Traverse_Class_1(p2, v);
					if (!p3)
						break;
					p2 = p3;
				}
				if (p2)
				{
					p2 = (p2->value == ']') ? p2+1 : 0;
					if (p2)
					{
						p2 = Parse_Spacing(p2);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Class_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Class_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == ']') ? p0+1 : 0;
			p2 = p2 ? 0 : p0;
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Range)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Range, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Comment(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Comment(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '#') ? p0+1 : 0;
			if (p2)
			{
				for (;;)
				{
					Node* p3 = Parse_EndOfLine(p2);
					p3 = p3 ? 0 : p2;
					if (p3)
					{
						p3 = (p3->value != 0) ? p3+1 : 0;
					}
					if (!p3)
						break;
					p2 = p3;
				}
				if (p2)
				{
					p2 = Parse_EndOfLine(p2);
				}
			}
			return p1;
		}

		static Node* Traverse_DOT(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_DOT(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '.') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_Definition(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Definition(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Identifier)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Identifier, p0));
			if (p2)
			{
				p2 = Parse_Spacing(p2);
				if (p2)
				{
					Node* p3 = p2->end.find(PTNodeType_LEFTARROW)->second;
					if (p3)
						v.push_back(PTNodeChild(PTNodeType_LEFTARROW, p2));
					if (p3)
					{
						Node* p4 = p3->end.find(PTNodeType_Expression)->second;
						if (p4)
							v.push_back(PTNodeChild(PTNodeType_Expression, p3));
						p3 = p4;
					}
					p2 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_EndOfFile(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_EndOfFile(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value != 0) ? p0+1 : 0;
			p2 = p2 ? 0 : p0;
			return p1;
		}

		static Node* Traverse_EndOfLine(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_EndOfLine(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\r') ? p0+1 : 0;
			if (p2)
			{
				p2 = (p2->value == '\n') ? p2+1 : 0;
			}
			if (!p2)
			{
				p2 = (p0->value == '\n') ? p0+1 : 0;
				if (!p2)
				{
					p2 = (p0->value == '\r') ? p0+1 : 0;
				}
			}
			return p1;
		}

		static Node* Traverse_Expression(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Expression(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Sequence)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Sequence, p0));
			if (p2)
			{
				for (;;)
				{
					Node* p3 = Traverse_Expression_1(p2, v);
					if (!p3)
						break;
					p2 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_Expression_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Expression_1(p0);
			if (!p1)
				return 0;
			Node* p2 = Parse_SLASH(p0);
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Sequence)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Sequence, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Grammar(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Grammar(p0);
			if (!p1)
				return 0;
			Node* p2 = Parse_Spacing(p0);
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Definition)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Definition, p2));
				if (p3)
				{
					for (;;)
					{
						Node* p4 = p3->end.find(PTNodeType_Definition)->second;
						if (p4)
							v.push_back(PTNodeChild(PTNodeType_Definition, p3));
						if (!p4)
							break;
						p3 = p4;
					}
					if (p3)
					{
						p3 = Parse_EndOfFile(p3);
					}
				}
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Identifier(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Identifier(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value >= 'a' && p0->value <= 'z') ? p0+1 : 0;
			if (!p2)
			{
				p2 = (p0->value >= 'A' && p0->value <= 'Z') ? p0+1 : 0;
				if (!p2)
				{
					p2 = (p0->value == '_') ? p0+1 : 0;
				}
			}
			if (p2)
			{
				for (;;)
				{
					Node* p3 = (p2->value >= 'a' && p2->value <= 'z') ? p2+1 : 0;
					if (!p3)
					{
						p3 = (p2->value >= 'A' && p2->value <= 'Z') ? p2+1 : 0;
						if (!p3)
						{
							p3 = (p2->value >= '0' && p2->value <= '9') ? p2+1 : 0;
							if (!p3)
							{
								p3 = (p2->value == '_') ? p2+1 : 0;
							}
						}
					}
					if (!p3)
						break;
					p2 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_LEFTARROW(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_LEFTARROW(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '<') ? p0+1 : 0;
			if (p2)
			{
				Node* p3 = (p2->value == '-') ? p2+1 : 0;
				if (!p3)
				{
					p3 = (p2->value == '=') ? p2+1 : 0;
					if (!p3)
					{
						p3 = (p2->value == '<') ? p2+1 : 0;
					}
				}
				if (p3)
				{
					p3 = Parse_Spacing(p3);
				}
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Literal(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal(p0);
			if (!p1)
				return 0;
			Node* p2 = Traverse_Literal_1(p0, v);
			if (!p2)
			{
				p2 = Traverse_Literal_2(p0, v);
			}
			return p1;
		}

		static Node* Traverse_Literal_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\'') ? p0+1 : 0;
			if (p2)
			{
				for (;;)
				{
					Node* p3 = Traverse_Literal_1_1(p2, v);
					if (!p3)
						break;
					p2 = p3;
				}
				if (p2)
				{
					p2 = (p2->value == '\'') ? p2+1 : 0;
					if (p2)
					{
						p2 = Parse_Spacing(p2);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Literal_1_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_1_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\'') ? p0+1 : 0;
			p2 = p2 ? 0 : p0;
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Char)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Char, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Literal_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_2(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\"') ? p0+1 : 0;
			if (p2)
			{
				for (;;)
				{
					Node* p3 = Traverse_Literal_2_1(p2, v);
					if (!p3)
						break;
					p2 = p3;
				}
				if (p2)
				{
					p2 = (p2->value == '\"') ? p2+1 : 0;
					if (p2)
					{
						p2 = Parse_Spacing(p2);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Literal_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_2_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\"') ? p0+1 : 0;
			p2 = p2 ? 0 : p0;
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Char)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Char, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_NOT(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_NOT(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '!') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_OPEN(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_OPEN(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '(') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_PLUS(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_PLUS(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '+') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_Prefix(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Prefix(p0);
			if (!p1)
				return 0;
			Node* p2 = Parse_AND(p0);
			if (!p2)
			{
				p2 = Parse_NOT(p0);
				if (!p2)
				{
					p2 = p0;
				}
			}
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Suffix)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Suffix, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Primary(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary(p0);
			if (!p1)
				return 0;
			Node* p2 = Traverse_Primary_1(p0, v);
			if (!p2)
			{
				p2 = Traverse_Primary_2(p0, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_1(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Identifier)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Identifier, p0));
			if (p2)
			{
				p2 = Parse_Spacing(p2);
				if (p2)
				{
					Node* p3 = p2->end.find(PTNodeType_LEFTARROW)->second;
					if (p3)
						v.push_back(PTNodeChild(PTNodeType_LEFTARROW, p2));
					p2 = p3 ? 0 : p2;
				}
			}
			return p1;
		}

		static Node* Traverse_Primary_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2(p0);
			if (!p1)
				return 0;
			Node* p2 = Traverse_Primary_2_1(p0, v);
			if (!p2)
			{
				p2 = Traverse_Primary_2_2(p0, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_1(p0);
			if (!p1)
				return 0;
			Node* p2 = Parse_OPEN(p0);
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Expression)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Expression, p2));
				if (p3)
				{
					p3 = Parse_CLOSE(p3);
				}
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Primary_2_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_2(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Literal)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Literal, p0));
			if (!p2)
			{
				p2 = Traverse_Primary_2_2_1(p0, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_2_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_2_1(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Class)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Class, p0));
			if (!p2)
			{
				p2 = Parse_DOT(p0);
			}
			return p1;
		}

		static Node* Traverse_QUESTION(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_QUESTION(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '?') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_Range(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Range(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Char)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Char, p0));
			if (p2)
			{
				Node* p3 = Traverse_Range_1(p2, v);
				if (!p3)
				{
					p3 = p2;
				}
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Range_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Range_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '-') ? p0+1 : 0;
			if (p2)
			{
				Node* p3 = p2->end.find(PTNodeType_Char)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Char, p2));
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_SLASH(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_SLASH(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '/') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_STAR(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_STAR(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '*') ? p0+1 : 0;
			if (p2)
			{
				p2 = Parse_Spacing(p2);
			}
			return p1;
		}

		static Node* Traverse_Sequence(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Sequence(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			for (;;)
			{
				Node* p3 = p2->end.find(PTNodeType_Prefix)->second;
				if (p3)
					v.push_back(PTNodeChild(PTNodeType_Prefix, p2));
				if (!p3)
					break;
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Space(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Space(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == ' ') ? p0+1 : 0;
			if (!p2)
			{
				p2 = (p0->value == '\t') ? p0+1 : 0;
				if (!p2)
				{
					p2 = Parse_EndOfLine(p0);
				}
			}
			return p1;
		}

		static Node* Traverse_Spacing(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Spacing(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			for (;;)
			{
				Node* p3 = Parse_Space(p2);
				if (!p3)
				{
					p3 = Parse_Comment(p2);
				}
				if (!p3)
					break;
				p2 = p3;
			}
			return p1;
		}

		static Node* Traverse_Suffix(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Suffix(p0);
			if (!p1)
				return 0;
			Node* p2 = p0->end.find(PTNodeType_Primary)->second;
			if (p2)
				v.push_back(PTNodeChild(PTNodeType_Primary, p0));
			if (p2)
			{
				Node* p3 = Parse_QUESTION(p2);
				if (!p3)
				{
					p3 = Parse_STAR(p2);
					if (!p3)
					{
						p3 = Parse_PLUS(p2);
						if (!p3)
						{
							p3 = p2;
						}
					}
				}
				p2 = p3;
			}
			return p1;
		}
	};
}

namespace PEGParser
{
	Node* Parse(PTNodeType _type, Node* _symbol)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Private::Parse_AND(_symbol);
			case PTNodeType_CLOSE: return Private::Parse_CLOSE(_symbol);
			case PTNodeType_Char: return Private::Parse_Char(_symbol);
			case PTNodeType_Class: return Private::Parse_Class(_symbol);
			case PTNodeType_Class_1: return Private::Parse_Class_1(_symbol);
			case PTNodeType_Comment: return Private::Parse_Comment(_symbol);
			case PTNodeType_DOT: return Private::Parse_DOT(_symbol);
			case PTNodeType_Definition: return Private::Parse_Definition(_symbol);
			case PTNodeType_EndOfFile: return Private::Parse_EndOfFile(_symbol);
			case PTNodeType_EndOfLine: return Private::Parse_EndOfLine(_symbol);
			case PTNodeType_Expression: return Private::Parse_Expression(_symbol);
			case PTNodeType_Expression_1: return Private::Parse_Expression_1(_symbol);
			case PTNodeType_Grammar: return Private::Parse_Grammar(_symbol);
			case PTNodeType_Identifier: return Private::Parse_Identifier(_symbol);
			case PTNodeType_LEFTARROW: return Private::Parse_LEFTARROW(_symbol);
			case PTNodeType_Literal: return Private::Parse_Literal(_symbol);
			case PTNodeType_Literal_1: return Private::Parse_Literal_1(_symbol);
			case PTNodeType_Literal_1_1: return Private::Parse_Literal_1_1(_symbol);
			case PTNodeType_Literal_2: return Private::Parse_Literal_2(_symbol);
			case PTNodeType_Literal_2_1: return Private::Parse_Literal_2_1(_symbol);
			case PTNodeType_NOT: return Private::Parse_NOT(_symbol);
			case PTNodeType_OPEN: return Private::Parse_OPEN(_symbol);
			case PTNodeType_PLUS: return Private::Parse_PLUS(_symbol);
			case PTNodeType_Prefix: return Private::Parse_Prefix(_symbol);
			case PTNodeType_Primary: return Private::Parse_Primary(_symbol);
			case PTNodeType_Primary_1: return Private::Parse_Primary_1(_symbol);
			case PTNodeType_Primary_2: return Private::Parse_Primary_2(_symbol);
			case PTNodeType_Primary_2_1: return Private::Parse_Primary_2_1(_symbol);
			case PTNodeType_Primary_2_2: return Private::Parse_Primary_2_2(_symbol);
			case PTNodeType_Primary_2_2_1: return Private::Parse_Primary_2_2_1(_symbol);
			case PTNodeType_QUESTION: return Private::Parse_QUESTION(_symbol);
			case PTNodeType_Range: return Private::Parse_Range(_symbol);
			case PTNodeType_Range_1: return Private::Parse_Range_1(_symbol);
			case PTNodeType_SLASH: return Private::Parse_SLASH(_symbol);
			case PTNodeType_STAR: return Private::Parse_STAR(_symbol);
			case PTNodeType_Sequence: return Private::Parse_Sequence(_symbol);
			case PTNodeType_Space: return Private::Parse_Space(_symbol);
			case PTNodeType_Spacing: return Private::Parse_Spacing(_symbol);
			case PTNodeType_Suffix: return Private::Parse_Suffix(_symbol);
		}
		return 0;
	}

	Node* Traverse(PTNodeType _type, Node* _symbol, PTNodeChildren& _children)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Private::Traverse_AND(_symbol, _children);
			case PTNodeType_CLOSE: return Private::Traverse_CLOSE(_symbol, _children);
			case PTNodeType_Char: return Private::Traverse_Char(_symbol, _children);
			case PTNodeType_Class: return Private::Traverse_Class(_symbol, _children);
			case PTNodeType_Class_1: return Private::Traverse_Class_1(_symbol, _children);
			case PTNodeType_Comment: return Private::Traverse_Comment(_symbol, _children);
			case PTNodeType_DOT: return Private::Traverse_DOT(_symbol, _children);
			case PTNodeType_Definition: return Private::Traverse_Definition(_symbol, _children);
			case PTNodeType_EndOfFile: return Private::Traverse_EndOfFile(_symbol, _children);
			case PTNodeType_EndOfLine: return Private::Traverse_EndOfLine(_symbol, _children);
			case PTNodeType_Expression: return Private::Traverse_Expression(_symbol, _children);
			case PTNodeType_Expression_1: return Private::Traverse_Expression_1(_symbol, _children);
			case PTNodeType_Grammar: return Private::Traverse_Grammar(_symbol, _children);
			case PTNodeType_Identifier: return Private::Traverse_Identifier(_symbol, _children);
			case PTNodeType_LEFTARROW: return Private::Traverse_LEFTARROW(_symbol, _children);
			case PTNodeType_Literal: return Private::Traverse_Literal(_symbol, _children);
			case PTNodeType_Literal_1: return Private::Traverse_Literal_1(_symbol, _children);
			case PTNodeType_Literal_1_1: return Private::Traverse_Literal_1_1(_symbol, _children);
			case PTNodeType_Literal_2: return Private::Traverse_Literal_2(_symbol, _children);
			case PTNodeType_Literal_2_1: return Private::Traverse_Literal_2_1(_symbol, _children);
			case PTNodeType_NOT: return Private::Traverse_NOT(_symbol, _children);
			case PTNodeType_OPEN: return Private::Traverse_OPEN(_symbol, _children);
			case PTNodeType_PLUS: return Private::Traverse_PLUS(_symbol, _children);
			case PTNodeType_Prefix: return Private::Traverse_Prefix(_symbol, _children);
			case PTNodeType_Primary: return Private::Traverse_Primary(_symbol, _children);
			case PTNodeType_Primary_1: return Private::Traverse_Primary_1(_symbol, _children);
			case PTNodeType_Primary_2: return Private::Traverse_Primary_2(_symbol, _children);
			case PTNodeType_Primary_2_1: return Private::Traverse_Primary_2_1(_symbol, _children);
			case PTNodeType_Primary_2_2: return Private::Traverse_Primary_2_2(_symbol, _children);
			case PTNodeType_Primary_2_2_1: return Private::Traverse_Primary_2_2_1(_symbol, _children);
			case PTNodeType_QUESTION: return Private::Traverse_QUESTION(_symbol, _children);
			case PTNodeType_Range: return Private::Traverse_Range(_symbol, _children);
			case PTNodeType_Range_1: return Private::Traverse_Range_1(_symbol, _children);
			case PTNodeType_SLASH: return Private::Traverse_SLASH(_symbol, _children);
			case PTNodeType_STAR: return Private::Traverse_STAR(_symbol, _children);
			case PTNodeType_Sequence: return Private::Traverse_Sequence(_symbol, _children);
			case PTNodeType_Space: return Private::Traverse_Space(_symbol, _children);
			case PTNodeType_Spacing: return Private::Traverse_Spacing(_symbol, _children);
			case PTNodeType_Suffix: return Private::Traverse_Suffix(_symbol, _children);
		}
		return 0;
	}
}
