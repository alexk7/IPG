// This file was automatically generated by IPG
// DO NOT EDIT!
#include "PEGParser.h"

using namespace PEGParser;

namespace
{
	PTNode* ParseRange(char _rangeBegin, char _rangeEnd, PTNode* _symbol)
	{
		if (_symbol->value < _rangeBegin)
			return 0;
		if (_symbol->value > _rangeEnd)
			return 0;
		return ++_symbol;
	}

	PTNode* ParseChar(char _char, PTNode* _symbol)
	{
		if (_symbol->value != _char)
			return 0;
		return ++_symbol;
	}

	PTNode* ParseAnyChar(PTNode* _symbol)
	{
		if (_symbol->value == 0)
			return 0;
		return ++_symbol;
	}

	struct Memo
	{
		Memo(PTNode* _symbol, PTNodeType _type)
		{
			std::pair<PTNodeTypeToPtr::iterator, bool> insertResult	=
				_symbol->end.insert(PTNodeTypeToPtr::value_type(_type, 0));

			ppNode = &insertResult.first->second;
			isValid = !insertResult.second;
		}

		PTNode** ppNode;
		bool isValid;
	};

	PTNode* Visit(PTNode* _symbol, PTNodeType _type, PTNodeVisitor& _visitor)
	{
		PTNode* end = _symbol->end[_type];
		if (end)
			_visitor(_symbol, _type);
		return end;
	}

	struct Parse
	{
		static PTNode* AND(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_AND);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('&', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* CLOSE(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar(')', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			return p1;
		}

		static PTNode* Char(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Char);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('\\', p0);
			if (p1)
			{
				PTNode* p2 = ::ParseChar('n', p1);
				if (!p2)
				{
					p2 = ::ParseChar('r', p1);
					if (!p2)
					{
						p2 = ::ParseChar('t', p1);
						if (!p2)
						{
							p2 = ::ParseChar('\'', p1);
							if (!p2)
							{
								p2 = ::ParseChar('\"', p1);
								if (!p2)
								{
									p2 = ::ParseChar('[', p1);
									if (!p2)
									{
										p2 = ::ParseChar(']', p1);
										if (!p2)
										{
											p2 = ::ParseChar('\\', p1);
											if (!p2)
											{
												p2 = ::ParseRange('1', '9', p1);
												if (p2)
												{
													for (;;)
													{
														PTNode* p3 = ::ParseRange('0', '9', p2);
														if (!p3)
															break;
														p2 = p3;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				p1 = p2;
			}
			if (!p1)
			{
				p1 = ::ParseChar('\\', p0);
				p1 = p1 ? 0 : p0;
				if (p1)
				{
					p1 = ::ParseAnyChar(p1);
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Class(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Class);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('[', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Class_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar(']', p1);
					if (p1)
					{
						p1 = Spacing(p1);
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Class_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Class_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar(']', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Range(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Comment(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar('#', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = EndOfLine(p1);
					p2 = p2 ? 0 : p1;
					if (p2)
					{
						p2 = ::ParseAnyChar(p2);
					}
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = EndOfLine(p1);
				}
			}
			return p1;
		}

		static PTNode* DOT(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_DOT);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('.', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Definition(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Definition);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Identifier(p0);
			if (p1)
			{
				p1 = Spacing(p1);
				if (p1)
				{
					p1 = LEFTARROW(p1);
					if (p1)
					{
						p1 = Expression(p1);
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* EndOfFile(PTNode* p0)
		{
			PTNode* p1 = ::ParseAnyChar(p0);
			p1 = p1 ? 0 : p0;
			return p1;
		}

		static PTNode* EndOfLine(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar('\r', p0);
			if (p1)
			{
				p1 = ::ParseChar('\n', p1);
			}
			if (!p1)
			{
				p1 = ::ParseChar('\n', p0);
				if (!p1)
				{
					p1 = ::ParseChar('\r', p0);
				}
			}
			return p1;
		}

		static PTNode* Expression(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Expression);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Sequence(p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Expression_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Expression_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Expression_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = SLASH(p0);
			if (p1)
			{
				p1 = Sequence(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Grammar(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Grammar);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Spacing(p0);
			if (p1)
			{
				p1 = Definition(p1);
				if (p1)
				{
					for (;;)
					{
						PTNode* p2 = Definition(p1);
						if (!p2)
							break;
						p1 = p2;
					}
					if (p1)
					{
						p1 = EndOfFile(p1);
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Identifier(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Identifier);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseRange('a', 'z', p0);
			if (!p1)
			{
				p1 = ::ParseRange('A', 'Z', p0);
				if (!p1)
				{
					p1 = ::ParseChar('_', p0);
				}
			}
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = ::ParseRange('a', 'z', p1);
					if (!p2)
					{
						p2 = ::ParseRange('A', 'Z', p1);
						if (!p2)
						{
							p2 = ::ParseRange('0', '9', p1);
							if (!p2)
							{
								p2 = ::ParseChar('_', p1);
							}
						}
					}
					if (!p2)
						break;
					p1 = p2;
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* LEFTARROW(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_LEFTARROW);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('<', p0);
			if (p1)
			{
				PTNode* p2 = ::ParseChar('-', p1);
				if (!p2)
				{
					p2 = ::ParseChar('=', p1);
					if (!p2)
					{
						p2 = ::ParseChar('<', p1);
					}
				}
				if (p2)
				{
					p1 = Spacing(p2);
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Literal(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Literal);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Literal_1(p0);
			if (!p1)
			{
				p1 = Literal_2(p0);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Literal_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Literal_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('\'', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Literal_1_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar('\'', p1);
					if (p1)
					{
						p1 = Spacing(p1);
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Literal_1_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Literal_1_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('\'', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Char(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Literal_2(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Literal_2);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('\"', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Literal_2_1(p1);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar('\"', p1);
					if (p1)
					{
						p1 = Spacing(p1);
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Literal_2_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Literal_2_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('\"', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = Char(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* NOT(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_NOT);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('!', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* OPEN(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar('(', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			return p1;
		}

		static PTNode* PLUS(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_PLUS);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('+', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Prefix(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Prefix);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = AND(p0);
			if (!p1)
			{
				p1 = NOT(p0);
				if (!p1)
				{
					p1 = p0;
				}
			}
			if (p1)
			{
				p1 = Suffix(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Primary(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Primary);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Primary_1(p0);
			if (!p1)
			{
				p1 = Primary_2(p0);
				if (!p1)
				{
					p1 = Literal(p0);
					if (!p1)
					{
						p1 = Class(p0);
						if (!p1)
						{
							p1 = DOT(p0);
						}
					}
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Primary_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Primary_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Identifier(p0);
			if (p1)
			{
				p1 = Spacing(p1);
				if (p1)
				{
					PTNode* p2 = LEFTARROW(p1);
					p1 = p2 ? 0 : p1;
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Primary_2(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Primary_2);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = OPEN(p0);
			if (p1)
			{
				p1 = Expression(p1);
				if (p1)
				{
					p1 = CLOSE(p1);
				}
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* QUESTION(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_QUESTION);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('?', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Range(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Range);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Char(p0);
			if (p1)
			{
				PTNode* p2 = Range_1(p1);
				if (!p2)
				{
					p2 = p1;
				}
				p1 = p2;
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Range_1(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Range_1);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('-', p0);
			if (p1)
			{
				p1 = Char(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* SLASH(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar('/', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			return p1;
		}

		static PTNode* STAR(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_STAR);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = ::ParseChar('*', p0);
			if (p1)
			{
				p1 = Spacing(p1);
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Sequence(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Sequence);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = p0;
			for (;;)
			{
				PTNode* p2 = Prefix(p1);
				if (!p2)
					break;
				p1 = p2;
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Space(PTNode* p0)
		{
			PTNode* p1 = ::ParseChar(' ', p0);
			if (!p1)
			{
				p1 = ::ParseChar('\t', p0);
				if (!p1)
				{
					p1 = EndOfLine(p0);
				}
			}
			return p1;
		}

		static PTNode* Spacing(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Spacing);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = p0;
			for (;;)
			{
				PTNode* p2 = Space(p1);
				if (!p2)
				{
					p2 = Comment(p1);
				}
				if (!p2)
					break;
				p1 = p2;
			}
			*memo.ppNode = p1;
			return p1;
		}

		static PTNode* Suffix(PTNode* p0)
		{
			Memo memo(p0, PTNodeType_Suffix);
			if (memo.isValid)
				return *memo.ppNode;
			PTNode* p1 = Primary(p0);
			if (p1)
			{
				PTNode* p2 = QUESTION(p1);
				if (!p2)
				{
					p2 = STAR(p1);
					if (!p2)
					{
						p2 = PLUS(p1);
						if (!p2)
						{
							p2 = p1;
						}
					}
				}
				p1 = p2;
			}
			*memo.ppNode = p1;
			return p1;
		}
	};

	struct Traverse
	{
		static PTNode* AND(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::AND(p0))
				return 0;
			PTNode* p1 = ::ParseChar('&', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* CLOSE(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::CLOSE(p0))
				return 0;
			PTNode* p1 = ::ParseChar(')', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* Char(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Char(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\\', p0);
			if (p1)
			{
				PTNode* p2 = ::ParseChar('n', p1);
				if (!p2)
				{
					p2 = ::ParseChar('r', p1);
					if (!p2)
					{
						p2 = ::ParseChar('t', p1);
						if (!p2)
						{
							p2 = ::ParseChar('\'', p1);
							if (!p2)
							{
								p2 = ::ParseChar('\"', p1);
								if (!p2)
								{
									p2 = ::ParseChar('[', p1);
									if (!p2)
									{
										p2 = ::ParseChar(']', p1);
										if (!p2)
										{
											p2 = ::ParseChar('\\', p1);
											if (!p2)
											{
												p2 = ::ParseRange('1', '9', p1);
												if (p2)
												{
													for (;;)
													{
														PTNode* p3 = ::ParseRange('0', '9', p2);
														if (!p3)
															break;
														p2 = p3;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				p1 = p2;
			}
			if (!p1)
			{
				p1 = ::ParseChar('\\', p0);
				p1 = p1 ? 0 : p0;
				if (p1)
				{
					p1 = ::ParseAnyChar(p1);
				}
			}
			return p1;
		}

		static PTNode* Class(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Class(p0))
				return 0;
			PTNode* p1 = ::ParseChar('[', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Class_1(p1, v);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar(']', p1);
					if (p1)
					{
						p1 = p1->end[PTNodeType_Spacing];
					}
				}
			}
			return p1;
		}

		static PTNode* Class_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Class_1(p0))
				return 0;
			PTNode* p1 = ::ParseChar(']', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Range, v);
			}
			return p1;
		}

		static PTNode* Comment(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Comment(p0))
				return 0;
			PTNode* p1 = ::ParseChar('#', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = EndOfLine(p1, v);
					p2 = p2 ? 0 : p1;
					if (p2)
					{
						p2 = ::ParseAnyChar(p2);
					}
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = EndOfLine(p1, v);
				}
			}
			return p1;
		}

		static PTNode* DOT(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::DOT(p0))
				return 0;
			PTNode* p1 = ::ParseChar('.', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* Definition(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Definition(p0))
				return 0;
			PTNode* p1 = ::Visit(p0, PTNodeType_Identifier, v);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
				if (p1)
				{
					p1 = ::Visit(p1, PTNodeType_LEFTARROW, v);
					if (p1)
					{
						p1 = ::Visit(p1, PTNodeType_Expression, v);
					}
				}
			}
			return p1;
		}

		static PTNode* EndOfFile(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::EndOfFile(p0))
				return 0;
			PTNode* p1 = ::ParseAnyChar(p0);
			p1 = p1 ? 0 : p0;
			return p1;
		}

		static PTNode* EndOfLine(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::EndOfLine(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\r', p0);
			if (p1)
			{
				p1 = ::ParseChar('\n', p1);
			}
			if (!p1)
			{
				p1 = ::ParseChar('\n', p0);
				if (!p1)
				{
					p1 = ::ParseChar('\r', p0);
				}
			}
			return p1;
		}

		static PTNode* Expression(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Expression(p0))
				return 0;
			PTNode* p1 = ::Visit(p0, PTNodeType_Sequence, v);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Expression_1(p1, v);
					if (!p2)
						break;
					p1 = p2;
				}
			}
			return p1;
		}

		static PTNode* Expression_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Expression_1(p0))
				return 0;
			PTNode* p1 = SLASH(p0, v);
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Sequence, v);
			}
			return p1;
		}

		static PTNode* Grammar(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Grammar(p0))
				return 0;
			PTNode* p1 = p0->end[PTNodeType_Spacing];
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Definition, v);
				if (p1)
				{
					for (;;)
					{
						PTNode* p2 = ::Visit(p1, PTNodeType_Definition, v);
						if (!p2)
							break;
						p1 = p2;
					}
					if (p1)
					{
						p1 = EndOfFile(p1, v);
					}
				}
			}
			return p1;
		}

		static PTNode* Identifier(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Identifier(p0))
				return 0;
			PTNode* p1 = ::ParseRange('a', 'z', p0);
			if (!p1)
			{
				p1 = ::ParseRange('A', 'Z', p0);
				if (!p1)
				{
					p1 = ::ParseChar('_', p0);
				}
			}
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = ::ParseRange('a', 'z', p1);
					if (!p2)
					{
						p2 = ::ParseRange('A', 'Z', p1);
						if (!p2)
						{
							p2 = ::ParseRange('0', '9', p1);
							if (!p2)
							{
								p2 = ::ParseChar('_', p1);
							}
						}
					}
					if (!p2)
						break;
					p1 = p2;
				}
			}
			return p1;
		}

		static PTNode* LEFTARROW(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::LEFTARROW(p0))
				return 0;
			PTNode* p1 = ::ParseChar('<', p0);
			if (p1)
			{
				PTNode* p2 = ::ParseChar('-', p1);
				if (!p2)
				{
					p2 = ::ParseChar('=', p1);
					if (!p2)
					{
						p2 = ::ParseChar('<', p1);
					}
				}
				if (p2)
				{
					p1 = p2->end[PTNodeType_Spacing];
				}
			}
			return p1;
		}

		static PTNode* Literal(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Literal(p0))
				return 0;
			PTNode* p1 = Literal_1(p0, v);
			if (!p1)
			{
				p1 = Literal_2(p0, v);
			}
			return p1;
		}

		static PTNode* Literal_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Literal_1(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\'', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Literal_1_1(p1, v);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar('\'', p1);
					if (p1)
					{
						p1 = p1->end[PTNodeType_Spacing];
					}
				}
			}
			return p1;
		}

		static PTNode* Literal_1_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Literal_1_1(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\'', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Char, v);
			}
			return p1;
		}

		static PTNode* Literal_2(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Literal_2(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\"', p0);
			if (p1)
			{
				for (;;)
				{
					PTNode* p2 = Literal_2_1(p1, v);
					if (!p2)
						break;
					p1 = p2;
				}
				if (p1)
				{
					p1 = ::ParseChar('\"', p1);
					if (p1)
					{
						p1 = p1->end[PTNodeType_Spacing];
					}
				}
			}
			return p1;
		}

		static PTNode* Literal_2_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Literal_2_1(p0))
				return 0;
			PTNode* p1 = ::ParseChar('\"', p0);
			p1 = p1 ? 0 : p0;
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Char, v);
			}
			return p1;
		}

		static PTNode* NOT(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::NOT(p0))
				return 0;
			PTNode* p1 = ::ParseChar('!', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* OPEN(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::OPEN(p0))
				return 0;
			PTNode* p1 = ::ParseChar('(', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* PLUS(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::PLUS(p0))
				return 0;
			PTNode* p1 = ::ParseChar('+', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* Prefix(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Prefix(p0))
				return 0;
			PTNode* p1 = p0->end[PTNodeType_AND];
			if (!p1)
			{
				p1 = p0->end[PTNodeType_NOT];
				if (!p1)
				{
					p1 = p0;
				}
			}
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Suffix, v);
			}
			return p1;
		}

		static PTNode* Primary(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Primary(p0))
				return 0;
			PTNode* p1 = Primary_1(p0, v);
			if (!p1)
			{
				p1 = Primary_2(p0, v);
				if (!p1)
				{
					p1 = ::Visit(p0, PTNodeType_Literal, v);
					if (!p1)
					{
						p1 = ::Visit(p0, PTNodeType_Class, v);
						if (!p1)
						{
							p1 = p0->end[PTNodeType_DOT];
						}
					}
				}
			}
			return p1;
		}

		static PTNode* Primary_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Primary_1(p0))
				return 0;
			PTNode* p1 = ::Visit(p0, PTNodeType_Identifier, v);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
				if (p1)
				{
					PTNode* p2 = ::Visit(p1, PTNodeType_LEFTARROW, v);
					p1 = p2 ? 0 : p1;
				}
			}
			return p1;
		}

		static PTNode* Primary_2(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Primary_2(p0))
				return 0;
			PTNode* p1 = OPEN(p0, v);
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Expression, v);
				if (p1)
				{
					p1 = CLOSE(p1, v);
				}
			}
			return p1;
		}

		static PTNode* QUESTION(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::QUESTION(p0))
				return 0;
			PTNode* p1 = ::ParseChar('?', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* Range(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Range(p0))
				return 0;
			PTNode* p1 = ::Visit(p0, PTNodeType_Char, v);
			if (p1)
			{
				PTNode* p2 = Range_1(p1, v);
				if (!p2)
				{
					p2 = p1;
				}
				p1 = p2;
			}
			return p1;
		}

		static PTNode* Range_1(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Range_1(p0))
				return 0;
			PTNode* p1 = ::ParseChar('-', p0);
			if (p1)
			{
				p1 = ::Visit(p1, PTNodeType_Char, v);
			}
			return p1;
		}

		static PTNode* SLASH(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::SLASH(p0))
				return 0;
			PTNode* p1 = ::ParseChar('/', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* STAR(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::STAR(p0))
				return 0;
			PTNode* p1 = ::ParseChar('*', p0);
			if (p1)
			{
				p1 = p1->end[PTNodeType_Spacing];
			}
			return p1;
		}

		static PTNode* Sequence(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Sequence(p0))
				return 0;
			PTNode* p1 = p0;
			for (;;)
			{
				PTNode* p2 = ::Visit(p1, PTNodeType_Prefix, v);
				if (!p2)
					break;
				p1 = p2;
			}
			return p1;
		}

		static PTNode* Space(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Space(p0))
				return 0;
			PTNode* p1 = ::ParseChar(' ', p0);
			if (!p1)
			{
				p1 = ::ParseChar('\t', p0);
				if (!p1)
				{
					p1 = EndOfLine(p0, v);
				}
			}
			return p1;
		}

		static PTNode* Spacing(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Spacing(p0))
				return 0;
			PTNode* p1 = p0;
			for (;;)
			{
				PTNode* p2 = Space(p1, v);
				if (!p2)
				{
					p2 = Comment(p1, v);
				}
				if (!p2)
					break;
				p1 = p2;
			}
			return p1;
		}

		static PTNode* Suffix(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::Suffix(p0))
				return 0;
			PTNode* p1 = ::Visit(p0, PTNodeType_Primary, v);
			if (p1)
			{
				PTNode* p2 = p1->end[PTNodeType_QUESTION];
				if (!p2)
				{
					p2 = p1->end[PTNodeType_STAR];
					if (!p2)
					{
						p2 = p1->end[PTNodeType_PLUS];
						if (!p2)
						{
							p2 = p1;
						}
					}
				}
				p1 = p2;
			}
			return p1;
		}
	};
}

namespace PEGParser
{
	PTNode* Parse(PTNodeType _type, PTNode* _symbol)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Parse::AND(_symbol);
			case PTNodeType_CLOSE: return Parse::CLOSE(_symbol);
			case PTNodeType_Char: return Parse::Char(_symbol);
			case PTNodeType_Class: return Parse::Class(_symbol);
			case PTNodeType_Class_1: return Parse::Class_1(_symbol);
			case PTNodeType_Comment: return Parse::Comment(_symbol);
			case PTNodeType_DOT: return Parse::DOT(_symbol);
			case PTNodeType_Definition: return Parse::Definition(_symbol);
			case PTNodeType_EndOfFile: return Parse::EndOfFile(_symbol);
			case PTNodeType_EndOfLine: return Parse::EndOfLine(_symbol);
			case PTNodeType_Expression: return Parse::Expression(_symbol);
			case PTNodeType_Expression_1: return Parse::Expression_1(_symbol);
			case PTNodeType_Grammar: return Parse::Grammar(_symbol);
			case PTNodeType_Identifier: return Parse::Identifier(_symbol);
			case PTNodeType_LEFTARROW: return Parse::LEFTARROW(_symbol);
			case PTNodeType_Literal: return Parse::Literal(_symbol);
			case PTNodeType_Literal_1: return Parse::Literal_1(_symbol);
			case PTNodeType_Literal_1_1: return Parse::Literal_1_1(_symbol);
			case PTNodeType_Literal_2: return Parse::Literal_2(_symbol);
			case PTNodeType_Literal_2_1: return Parse::Literal_2_1(_symbol);
			case PTNodeType_NOT: return Parse::NOT(_symbol);
			case PTNodeType_OPEN: return Parse::OPEN(_symbol);
			case PTNodeType_PLUS: return Parse::PLUS(_symbol);
			case PTNodeType_Prefix: return Parse::Prefix(_symbol);
			case PTNodeType_Primary: return Parse::Primary(_symbol);
			case PTNodeType_Primary_1: return Parse::Primary_1(_symbol);
			case PTNodeType_Primary_2: return Parse::Primary_2(_symbol);
			case PTNodeType_QUESTION: return Parse::QUESTION(_symbol);
			case PTNodeType_Range: return Parse::Range(_symbol);
			case PTNodeType_Range_1: return Parse::Range_1(_symbol);
			case PTNodeType_SLASH: return Parse::SLASH(_symbol);
			case PTNodeType_STAR: return Parse::STAR(_symbol);
			case PTNodeType_Sequence: return Parse::Sequence(_symbol);
			case PTNodeType_Space: return Parse::Space(_symbol);
			case PTNodeType_Spacing: return Parse::Spacing(_symbol);
			case PTNodeType_Suffix: return Parse::Suffix(_symbol);
		}
		return 0;
	}

	PTNode* Traverse(PTNodeType _type, PTNode* _symbol, PTNodeVisitor& _visitor)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Traverse::AND(_symbol, _visitor);
			case PTNodeType_CLOSE: return Traverse::CLOSE(_symbol, _visitor);
			case PTNodeType_Char: return Traverse::Char(_symbol, _visitor);
			case PTNodeType_Class: return Traverse::Class(_symbol, _visitor);
			case PTNodeType_Class_1: return Traverse::Class_1(_symbol, _visitor);
			case PTNodeType_Comment: return Traverse::Comment(_symbol, _visitor);
			case PTNodeType_DOT: return Traverse::DOT(_symbol, _visitor);
			case PTNodeType_Definition: return Traverse::Definition(_symbol, _visitor);
			case PTNodeType_EndOfFile: return Traverse::EndOfFile(_symbol, _visitor);
			case PTNodeType_EndOfLine: return Traverse::EndOfLine(_symbol, _visitor);
			case PTNodeType_Expression: return Traverse::Expression(_symbol, _visitor);
			case PTNodeType_Expression_1: return Traverse::Expression_1(_symbol, _visitor);
			case PTNodeType_Grammar: return Traverse::Grammar(_symbol, _visitor);
			case PTNodeType_Identifier: return Traverse::Identifier(_symbol, _visitor);
			case PTNodeType_LEFTARROW: return Traverse::LEFTARROW(_symbol, _visitor);
			case PTNodeType_Literal: return Traverse::Literal(_symbol, _visitor);
			case PTNodeType_Literal_1: return Traverse::Literal_1(_symbol, _visitor);
			case PTNodeType_Literal_1_1: return Traverse::Literal_1_1(_symbol, _visitor);
			case PTNodeType_Literal_2: return Traverse::Literal_2(_symbol, _visitor);
			case PTNodeType_Literal_2_1: return Traverse::Literal_2_1(_symbol, _visitor);
			case PTNodeType_NOT: return Traverse::NOT(_symbol, _visitor);
			case PTNodeType_OPEN: return Traverse::OPEN(_symbol, _visitor);
			case PTNodeType_PLUS: return Traverse::PLUS(_symbol, _visitor);
			case PTNodeType_Prefix: return Traverse::Prefix(_symbol, _visitor);
			case PTNodeType_Primary: return Traverse::Primary(_symbol, _visitor);
			case PTNodeType_Primary_1: return Traverse::Primary_1(_symbol, _visitor);
			case PTNodeType_Primary_2: return Traverse::Primary_2(_symbol, _visitor);
			case PTNodeType_QUESTION: return Traverse::QUESTION(_symbol, _visitor);
			case PTNodeType_Range: return Traverse::Range(_symbol, _visitor);
			case PTNodeType_Range_1: return Traverse::Range_1(_symbol, _visitor);
			case PTNodeType_SLASH: return Traverse::SLASH(_symbol, _visitor);
			case PTNodeType_STAR: return Traverse::STAR(_symbol, _visitor);
			case PTNodeType_Sequence: return Traverse::Sequence(_symbol, _visitor);
			case PTNodeType_Space: return Traverse::Space(_symbol, _visitor);
			case PTNodeType_Spacing: return Traverse::Spacing(_symbol, _visitor);
			case PTNodeType_Suffix: return Traverse::Suffix(_symbol, _visitor);
		}
		return 0;
	}
}
