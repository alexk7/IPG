// This file was automatically generated by IPG on Tue Jul 19 14:38:04 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#ifndef PEGPARSER_H
#define PEGPARSER_H

#ifndef BOOTSTRAP_TEST
#include <vector>
#include <bitset>
#include <boost/shared_ptr.hpp>
#include <boost/unordered_map.hpp>
#endif

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_AND = 0,
		SymbolType_CLOSE = 1,
		SymbolType_Char = 2,
		SymbolType_Class = 3,
		SymbolType_Comment = 4,
		SymbolType_DOT = 5,
		SymbolType_Definition = 6,
		SymbolType_EndOfFile = 7,
		SymbolType_EndOfLine = 8,
		SymbolType_Expression = 9,
		SymbolType_Grammar = 10,
		SymbolType_Identifier = 11,
		SymbolType_LEFTARROW = 12,
		SymbolType_Literal = 13,
		SymbolType_NOT = 14,
		SymbolType_OPEN = 15,
		SymbolType_PLUS = 16,
		SymbolType_Prefix = 17,
		SymbolType_Primary = 18,
		SymbolType_QUESTION = 19,
		SymbolType_Range = 20,
		SymbolType_SLASH = 21,
		SymbolType_STAR = 22,
		SymbolType_Sequence = 23,
		SymbolType_Space = 24,
		SymbolType_Spacing = 25,
		SymbolType_Suffix = 26,
		SymbolTypeCount
	};

	typedef std::pair<SymbolType, const char*> Symbol;
	typedef std::vector<Symbol> Symbols;
	typedef std::bitset<SymbolTypeCount> SymbolTypeSet;
	typedef std::pair<SymbolTypeSet, const char*> MemoValue;
	typedef boost::unordered_multimap<const char*, MemoValue> MemoMap;

	const char* SymbolName(SymbolType _type);

	class Parser
	{
	public:
		const char* Parse(SymbolType _type, const char* _symbol);
		const char* Traverse(SymbolType _type, const char* _symbol, Symbols& _children);
		void Print(std::ostream& _os, SymbolType _type, const char* _pNode, int _tabs = 0, int _maxLineSize = 100);

	private:
		const char** GetEnd(SymbolType _type, const char* _pBegin);
		void SetEnd(SymbolType _type, const char* _pBegin, const char* _pEnd);
		const char* Visit(SymbolType _type, const char* _p, Symbols& _v);
		MemoMap memoMap;
	};

	class Iterator
	{
	public:
		Iterator(SymbolType _type, const char* _pNode = 0);
		Iterator(const Iterator& _iOther);
		operator bool() const;
		Iterator& operator++();
		SymbolType GetType() const;
		const char* Begin() const;
		const char* End() const;
		Iterator GetChild(SymbolType _childT);
		Iterator GetNext(SymbolType _childT);
		void Print(std::ostream& _os, int _tabs = 0, int _maxLineSize = 100);

	private:
		Iterator(boost::shared_ptr<Parser> _pParser, boost::shared_ptr<Symbols> _pSiblings, SymbolType _childType);
		Iterator(const Iterator& _iOther, SymbolType _childType);
		void GoToNext(SymbolType _childType);
		void SkipSiblingsWithWrongType(SymbolType _childType);
		boost::shared_ptr<Symbols> GetChildren();

		SymbolType mType;
		const char* mpNode;
		boost::shared_ptr<Symbols> mpSiblings;
		Symbols::iterator miCurrent;
		boost::shared_ptr<Symbols> mpChildren;
		boost::shared_ptr<Parser> mpParser;
	};

	std::ostream& operator<<(std::ostream& _os, const Iterator& _i);
}

#endif
