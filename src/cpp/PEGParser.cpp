// This file was automatically generated by IPG on Mon Jul 18 21:57:38 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <vector>
#include <boost/shared_ptr.hpp>
#include <boost/unordered_map.hpp>

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_AND = 1,
		SymbolType_CLOSE = 2,
		SymbolType_Char = 3,
		SymbolType_Class = 4,
		SymbolType_Comment = 5,
		SymbolType_DOT = 6,
		SymbolType_Definition = 7,
		SymbolType_EndOfFile = 8,
		SymbolType_EndOfLine = 9,
		SymbolType_Expression = 10,
		SymbolType_Grammar = 11,
		SymbolType_Identifier = 12,
		SymbolType_LEFTARROW = 13,
		SymbolType_Literal = 14,
		SymbolType_NOT = 15,
		SymbolType_OPEN = 16,
		SymbolType_PLUS = 17,
		SymbolType_Prefix = 18,
		SymbolType_Primary = 19,
		SymbolType_QUESTION = 20,
		SymbolType_Range = 21,
		SymbolType_SLASH = 22,
		SymbolType_STAR = 23,
		SymbolType_Sequence = 24,
		SymbolType_Space = 25,
		SymbolType_Spacing = 26,
		SymbolType_Suffix = 27,
	};

	struct Node;
	typedef boost::unordered_map<SymbolType, Node*> SymbolTypeToPtr;

	struct Node
	{
		char value;
		SymbolTypeToPtr end;
	};

	typedef std::pair<SymbolType, Node*> PTNodeChild;
	typedef std::vector<PTNodeChild> PTNodeChildren;

	const char* SymbolName(SymbolType _type);

	class Parser
	{
	public:
		Node* Parse(SymbolType _type, Node* _symbol);
		Node* Traverse(SymbolType _type, Node* _symbol, PTNodeChildren& _children);
		void Print(std::ostream& _os, SymbolType _type, Node* _pNode, int _tabs = 0, int _maxLineSize = 100);

	private:
		Node* Visit(SymbolType _type, Node* _p, PTNodeChildren& _v);
		Node* Parse_AND(Node* p);
		Node* Parse_CLOSE(Node* p);
		Node* Parse_Char(Node* p);
		Node* Parse_Class(Node* p);
		Node* Parse_Comment(Node* p);
		Node* Parse_DOT(Node* p);
		Node* Parse_Definition(Node* p);
		Node* Parse_EndOfFile(Node* p);
		Node* Parse_EndOfLine(Node* p);
		Node* Parse_Expression(Node* p);
		Node* Parse_Grammar(Node* p);
		Node* Parse_Identifier(Node* p);
		Node* Parse_LEFTARROW(Node* p);
		Node* Parse_Literal(Node* p);
		Node* Parse_NOT(Node* p);
		Node* Parse_OPEN(Node* p);
		Node* Parse_PLUS(Node* p);
		Node* Parse_Prefix(Node* p);
		Node* Parse_Primary(Node* p);
		Node* Parse_QUESTION(Node* p);
		Node* Parse_Range(Node* p);
		Node* Parse_SLASH(Node* p);
		Node* Parse_STAR(Node* p);
		Node* Parse_Sequence(Node* p);
		Node* Parse_Space(Node* p);
		Node* Parse_Spacing(Node* p);
		Node* Parse_Suffix(Node* p);
		Node* Traverse_Class(Node* p, PTNodeChildren& v);
		Node* Traverse_Definition(Node* p, PTNodeChildren& v);
		Node* Traverse_Expression(Node* p, PTNodeChildren& v);
		Node* Traverse_Grammar(Node* p, PTNodeChildren& v);
		Node* Traverse_Literal(Node* p, PTNodeChildren& v);
		Node* Traverse_Prefix(Node* p, PTNodeChildren& v);
		Node* Traverse_Primary(Node* p, PTNodeChildren& v);
		Node* Traverse_Range(Node* p, PTNodeChildren& v);
		Node* Traverse_Sequence(Node* p, PTNodeChildren& v);
		Node* Traverse_Suffix(Node* p, PTNodeChildren& v);
	};

	class PTItr
	{
	public:
		PTItr(SymbolType _type, Node* _pNode = 0);
		PTItr(const PTItr& _iOther);
		operator bool() const;
		PTItr& operator++();
		SymbolType GetType() const;
		Node* Begin() const;
		Node* End() const;
		PTItr GetChild(SymbolType _childT);
		PTItr GetNext(SymbolType _childT);

	private:
		PTItr(boost::shared_ptr<Parser> _pParser, boost::shared_ptr<PTNodeChildren> _pSiblings, SymbolType _childType);
		PTItr(const PTItr& _iOther, SymbolType _childType);
		void GoToNext(SymbolType _childType);
		void SkipSiblingsWithWrongType(SymbolType _childType);
		boost::shared_ptr<PTNodeChildren> GetChildren();

		SymbolType mType;
		Node* mpNode;
		boost::shared_ptr<PTNodeChildren> mpSiblings;
		PTNodeChildren::iterator miCurrent;
		boost::shared_ptr<PTNodeChildren> mpChildren;
		boost::shared_ptr<Parser> mpParser;
	};

	std::ostream& operator<<(std::ostream& _os, const PTItr& _i);
}

namespace
{
	typedef PEGParser::SymbolTypeToPtr::value_type Memo;
	typedef PEGParser::SymbolTypeToPtr::iterator MemoIterator;
	typedef std::pair<PEGParser::SymbolTypeToPtr::iterator, bool> MemoInsertResult;

	struct EscapeChar
	{
		EscapeChar(char _c);
		char c;
	};

	EscapeChar::EscapeChar(char _c) : c(_c)
	{
	}

	std::ostream& operator<<(std::ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\\': c = '\\'; break;
			case '\n': c = 'n';  break;
			case '\r': c = 'r';  break;
			case '\t': c = 't';  break;
			case '\'': c = '\''; break;
			case '\"': c = '\"'; break;
			default:
				_os.put(c);
				return _os;
		}
		_os.put('\\');
		_os.put(c);
		return _os;
	}
}

const char* PEGParser::SymbolName(PEGParser::SymbolType _type)
{
	switch (_type)
	{
		case SymbolType_AND: return "AND";
		case SymbolType_CLOSE: return "CLOSE";
		case SymbolType_Char: return "Char";
		case SymbolType_Class: return "Class";
		case SymbolType_Comment: return "Comment";
		case SymbolType_DOT: return "DOT";
		case SymbolType_Definition: return "Definition";
		case SymbolType_EndOfFile: return "EndOfFile";
		case SymbolType_EndOfLine: return "EndOfLine";
		case SymbolType_Expression: return "Expression";
		case SymbolType_Grammar: return "Grammar";
		case SymbolType_Identifier: return "Identifier";
		case SymbolType_LEFTARROW: return "LEFTARROW";
		case SymbolType_Literal: return "Literal";
		case SymbolType_NOT: return "NOT";
		case SymbolType_OPEN: return "OPEN";
		case SymbolType_PLUS: return "PLUS";
		case SymbolType_Prefix: return "Prefix";
		case SymbolType_Primary: return "Primary";
		case SymbolType_QUESTION: return "QUESTION";
		case SymbolType_Range: return "Range";
		case SymbolType_SLASH: return "SLASH";
		case SymbolType_STAR: return "STAR";
		case SymbolType_Sequence: return "Sequence";
		case SymbolType_Space: return "Space";
		case SymbolType_Spacing: return "Spacing";
		case SymbolType_Suffix: return "Suffix";
	}
}

PEGParser::Node* PEGParser::Parser::Parse(SymbolType _type, PEGParser::Node* _symbol)
{
	switch (_type)
	{
		case SymbolType_AND: return Parse_AND(_symbol);
		case SymbolType_CLOSE: return Parse_CLOSE(_symbol);
		case SymbolType_Char: return Parse_Char(_symbol);
		case SymbolType_Class: return Parse_Class(_symbol);
		case SymbolType_Comment: return Parse_Comment(_symbol);
		case SymbolType_DOT: return Parse_DOT(_symbol);
		case SymbolType_Definition: return Parse_Definition(_symbol);
		case SymbolType_EndOfFile: return Parse_EndOfFile(_symbol);
		case SymbolType_EndOfLine: return Parse_EndOfLine(_symbol);
		case SymbolType_Expression: return Parse_Expression(_symbol);
		case SymbolType_Grammar: return Parse_Grammar(_symbol);
		case SymbolType_Identifier: return Parse_Identifier(_symbol);
		case SymbolType_LEFTARROW: return Parse_LEFTARROW(_symbol);
		case SymbolType_Literal: return Parse_Literal(_symbol);
		case SymbolType_NOT: return Parse_NOT(_symbol);
		case SymbolType_OPEN: return Parse_OPEN(_symbol);
		case SymbolType_PLUS: return Parse_PLUS(_symbol);
		case SymbolType_Prefix: return Parse_Prefix(_symbol);
		case SymbolType_Primary: return Parse_Primary(_symbol);
		case SymbolType_QUESTION: return Parse_QUESTION(_symbol);
		case SymbolType_Range: return Parse_Range(_symbol);
		case SymbolType_SLASH: return Parse_SLASH(_symbol);
		case SymbolType_STAR: return Parse_STAR(_symbol);
		case SymbolType_Sequence: return Parse_Sequence(_symbol);
		case SymbolType_Space: return Parse_Space(_symbol);
		case SymbolType_Spacing: return Parse_Spacing(_symbol);
		case SymbolType_Suffix: return Parse_Suffix(_symbol);
	}
	return 0;
}

PEGParser::Node* PEGParser::Parser::Traverse(PEGParser::SymbolType _type, PEGParser::Node* _symbol, PEGParser::PTNodeChildren& _children)
{
	switch (_type)
	{
		case SymbolType_Class: return Traverse_Class(_symbol, _children);
		case SymbolType_Definition: return Traverse_Definition(_symbol, _children);
		case SymbolType_Expression: return Traverse_Expression(_symbol, _children);
		case SymbolType_Grammar: return Traverse_Grammar(_symbol, _children);
		case SymbolType_Literal: return Traverse_Literal(_symbol, _children);
		case SymbolType_Prefix: return Traverse_Prefix(_symbol, _children);
		case SymbolType_Primary: return Traverse_Primary(_symbol, _children);
		case SymbolType_Range: return Traverse_Range(_symbol, _children);
		case SymbolType_Sequence: return Traverse_Sequence(_symbol, _children);
		case SymbolType_Suffix: return Traverse_Suffix(_symbol, _children);
		case SymbolType_AND:
		case SymbolType_CLOSE:
		case SymbolType_Char:
		case SymbolType_Comment:
		case SymbolType_DOT:
		case SymbolType_EndOfFile:
		case SymbolType_EndOfLine:
		case SymbolType_Identifier:
		case SymbolType_LEFTARROW:
		case SymbolType_NOT:
		case SymbolType_OPEN:
		case SymbolType_PLUS:
		case SymbolType_QUESTION:
		case SymbolType_SLASH:
		case SymbolType_STAR:
		case SymbolType_Space:
		case SymbolType_Spacing:
		default:
			return Parse(_type, _symbol);
	}
}

void PEGParser::Parser::Print(std::ostream& _os, PEGParser::SymbolType _type, PEGParser::Node* _pNode, int _tabs, int _maxLineSize)
{
	PTNodeChildren children;
	Node* pEnd = Traverse(_type, _pNode, children);
	if (!pEnd)
	{
		std::ostringstream oss;
		oss << "Parsing Failed for \"" << SymbolName(_type) << "\"";
		throw std::runtime_error(oss.str());
	}

	int tabCount = _tabs;
	while (tabCount--)
		_os << "    ";

	_os << SymbolName(_type) << ": \"";

	size_t lineSize = 0;
	for (Node* p = _pNode; p != pEnd; ++p)
	{
		_os << EscapeChar(p->value);
		if (++lineSize >= _maxLineSize)
		{
			_os << "...";
			break;
		}
	}

	_os << "\"\n";

	for (PTNodeChildren::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
		Print(_os, i->first, i->second, _tabs + 1, _maxLineSize);
}

PEGParser::Node* PEGParser::Parser::Visit(PEGParser::SymbolType _type, PEGParser::Node* _p, PEGParser::PTNodeChildren& _v)
{
	Node* pEnd = Parse(_type, _p);
	if (pEnd)
		_v.push_back(PTNodeChild(_type, _p));
	return pEnd;
}

PEGParser::Node* PEGParser::Parser::Parse_AND(PEGParser::Node* p)
{
	if (p->value == '&') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_CLOSE(PEGParser::Node* p)
{
	if (p->value == ')') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Char(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Char, 0));
	if (!r.second) return r.first->second;
	Node* b = p;
	if (p->value == '\\') ++p; else p = 0;
	if (p)
	{
		Node* b2 = p;
		if (p->value == 'n') ++p; else p = 0;
		if (!p)
		{
			p = b2;
			if (p->value == 'r') ++p; else p = 0;
			if (!p)
			{
				p = b2;
				if (p->value == 't') ++p; else p = 0;
				if (!p)
				{
					p = b2;
					if (p->value == '\'') ++p; else p = 0;
					if (!p)
					{
						p = b2;
						if (p->value == '\"') ++p; else p = 0;
						if (!p)
						{
							p = b2;
							if (p->value == '[') ++p; else p = 0;
							if (!p)
							{
								p = b2;
								if (p->value == ']') ++p; else p = 0;
								if (!p)
								{
									p = b2;
									if (p->value == '\\') ++p; else p = 0;
									if (!p)
									{
										p = b2;
										if (p->value >= '1' && p->value <= '9') ++p; else p = 0;
										if (p)
										{
											for (;;)
											{
												Node* b3 = p;
												if (p->value >= '0' && p->value <= '9') ++p; else p = 0;
												if (!p)
												{
													p = b3;
													break;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!p)
	{
		p = b;
		if (p->value == '\\') ++p; else p = 0;
		if (p) p = 0; else p = b;
		if (p)
		{
			if (p->value != 0) ++p; else p = 0;
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Class(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Class, 0));
	if (!r.second) return r.first->second;
	if (p->value == '[') ++p; else p = 0;
	if (p)
	{
		for (;;)
		{
			Node* b = p;
			if (p->value == ']') ++p; else p = 0;
			if (p) p = 0; else p = b;
			if (p)
			{
				p = Parse(SymbolType_Range, p);
			}
			if (!p)
			{
				p = b;
				break;
			}
		}
		if (p)
		{
			if (p->value == ']') ++p; else p = 0;
			if (p)
			{
				p = Parse(SymbolType_Spacing, p);
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Comment(PEGParser::Node* p)
{
	if (p->value == '#') ++p; else p = 0;
	if (p)
	{
		for (;;)
		{
			Node* b = p;
			p = Parse(SymbolType_EndOfLine, p);
			if (p) p = 0; else p = b;
			if (p)
			{
				if (p->value != 0) ++p; else p = 0;
			}
			if (!p)
			{
				p = b;
				break;
			}
		}
		if (p)
		{
			p = Parse(SymbolType_EndOfLine, p);
		}
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_DOT(PEGParser::Node* p)
{
	if (p->value == '.') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Definition(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Definition, 0));
	if (!r.second) return r.first->second;
	p = Parse(SymbolType_Identifier, p);
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
		if (p)
		{
			p = Parse(SymbolType_LEFTARROW, p);
			if (p)
			{
				p = Parse(SymbolType_Expression, p);
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_EndOfFile(PEGParser::Node* p)
{
	Node* b = p;
	if (p->value != 0) ++p; else p = 0;
	if (p) p = 0; else p = b;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_EndOfLine(PEGParser::Node* p)
{
	Node* b = p;
	if (p->value == '\r') ++p; else p = 0;
	if (p)
	{
		if (p->value == '\n') ++p; else p = 0;
	}
	if (!p)
	{
		p = b;
		if (p->value == '\n') ++p; else p = 0;
		if (!p)
		{
			p = b;
			if (p->value == '\r') ++p; else p = 0;
		}
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Expression(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Expression, 0));
	if (!r.second) return r.first->second;
	p = Parse(SymbolType_Sequence, p);
	if (p)
	{
		for (;;)
		{
			Node* b = p;
			p = Parse(SymbolType_SLASH, p);
			if (p)
			{
				p = Parse(SymbolType_Sequence, p);
			}
			if (!p)
			{
				p = b;
				break;
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Grammar(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Grammar, 0));
	if (!r.second) return r.first->second;
	p = Parse(SymbolType_Spacing, p);
	if (p)
	{
		p = Parse(SymbolType_Definition, p);
		if (p)
		{
			for (;;)
			{
				Node* b = p;
				p = Parse(SymbolType_Definition, p);
				if (!p)
				{
					p = b;
					break;
				}
			}
			if (p)
			{
				p = Parse(SymbolType_EndOfFile, p);
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Identifier(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Identifier, 0));
	if (!r.second) return r.first->second;
	Node* b = p;
	if (p->value >= 'a' && p->value <= 'z') ++p; else p = 0;
	if (!p)
	{
		p = b;
		if (p->value >= 'A' && p->value <= 'Z') ++p; else p = 0;
		if (!p)
		{
			p = b;
			if (p->value == '_') ++p; else p = 0;
		}
	}
	if (p)
	{
		for (;;)
		{
			Node* b2 = p;
			if (p->value >= 'a' && p->value <= 'z') ++p; else p = 0;
			if (!p)
			{
				p = b2;
				if (p->value >= 'A' && p->value <= 'Z') ++p; else p = 0;
				if (!p)
				{
					p = b2;
					if (p->value >= '0' && p->value <= '9') ++p; else p = 0;
					if (!p)
					{
						p = b2;
						if (p->value == '_') ++p; else p = 0;
					}
				}
			}
			if (!p)
			{
				p = b2;
				break;
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_LEFTARROW(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_LEFTARROW, 0));
	if (!r.second) return r.first->second;
	if (p->value == '<') ++p; else p = 0;
	if (p)
	{
		Node* b = p;
		if (p->value == '-') ++p; else p = 0;
		if (!p)
		{
			p = b;
			if (p->value == '=') ++p; else p = 0;
			if (!p)
			{
				p = b;
				if (p->value == '<') ++p; else p = 0;
			}
		}
		if (p)
		{
			p = Parse(SymbolType_Spacing, p);
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Literal(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Literal, 0));
	if (!r.second) return r.first->second;
	Node* b = p;
	if (p->value == '\'') ++p; else p = 0;
	if (p)
	{
		for (;;)
		{
			Node* b2 = p;
			if (p->value == '\'') ++p; else p = 0;
			if (p) p = 0; else p = b2;
			if (p)
			{
				p = Parse(SymbolType_Char, p);
			}
			if (!p)
			{
				p = b2;
				break;
			}
		}
		if (p)
		{
			if (p->value == '\'') ++p; else p = 0;
			if (p)
			{
				p = Parse(SymbolType_Spacing, p);
			}
		}
	}
	if (!p)
	{
		p = b;
		if (p->value == '\"') ++p; else p = 0;
		if (p)
		{
			for (;;)
			{
				Node* b3 = p;
				if (p->value == '\"') ++p; else p = 0;
				if (p) p = 0; else p = b3;
				if (p)
				{
					p = Parse(SymbolType_Char, p);
				}
				if (!p)
				{
					p = b3;
					break;
				}
			}
			if (p)
			{
				if (p->value == '\"') ++p; else p = 0;
				if (p)
				{
					p = Parse(SymbolType_Spacing, p);
				}
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_NOT(PEGParser::Node* p)
{
	if (p->value == '!') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_OPEN(PEGParser::Node* p)
{
	if (p->value == '(') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_PLUS(PEGParser::Node* p)
{
	if (p->value == '+') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Prefix(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Prefix, 0));
	if (!r.second) return r.first->second;
	Node* b = p;
	p = Parse(SymbolType_AND, p);
	if (!p)
	{
		p = b;
		p = Parse(SymbolType_NOT, p);
		if (!p)
		{
			p = b;
		}
	}
	if (p)
	{
		p = Parse(SymbolType_Suffix, p);
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Primary(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Primary, 0));
	if (!r.second) return r.first->second;
	Node* b = p;
	p = Parse(SymbolType_Identifier, p);
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
		if (p)
		{
			Node* b2 = p;
			p = Parse(SymbolType_LEFTARROW, p);
			if (p) p = 0; else p = b2;
		}
	}
	if (!p)
	{
		p = b;
		p = Parse(SymbolType_OPEN, p);
		if (p)
		{
			p = Parse(SymbolType_Expression, p);
			if (p)
			{
				p = Parse(SymbolType_CLOSE, p);
			}
		}
		if (!p)
		{
			p = b;
			p = Parse(SymbolType_Literal, p);
			if (!p)
			{
				p = b;
				p = Parse(SymbolType_Class, p);
				if (!p)
				{
					p = b;
					p = Parse(SymbolType_DOT, p);
				}
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_QUESTION(PEGParser::Node* p)
{
	if (p->value == '?') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Range(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Range, 0));
	if (!r.second) return r.first->second;
	p = Parse(SymbolType_Char, p);
	if (p)
	{
		Node* b = p;
		if (p->value == '-') ++p; else p = 0;
		if (p)
		{
			p = Parse(SymbolType_Char, p);
		}
		if (!p)
		{
			p = b;
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_SLASH(PEGParser::Node* p)
{
	if (p->value == '/') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_STAR(PEGParser::Node* p)
{
	if (p->value == '*') ++p; else p = 0;
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Sequence(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Sequence, 0));
	if (!r.second) return r.first->second;
	for (;;)
	{
		Node* b = p;
		p = Parse(SymbolType_Prefix, p);
		if (!p)
		{
			p = b;
			break;
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Space(PEGParser::Node* p)
{
	Node* b = p;
	if (p->value == ' ') ++p; else p = 0;
	if (!p)
	{
		p = b;
		if (p->value == '\t') ++p; else p = 0;
		if (!p)
		{
			p = b;
			p = Parse(SymbolType_EndOfLine, p);
		}
	}
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Spacing(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Spacing, 0));
	if (!r.second) return r.first->second;
	for (;;)
	{
		Node* b = p;
		p = Parse(SymbolType_Space, p);
		if (!p)
		{
			p = b;
			p = Parse(SymbolType_Comment, p);
		}
		if (!p)
		{
			p = b;
			break;
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Parse_Suffix(PEGParser::Node* p)
{
	MemoInsertResult r = p->end.insert(Memo(SymbolType_Suffix, 0));
	if (!r.second) return r.first->second;
	p = Parse(SymbolType_Primary, p);
	if (p)
	{
		Node* b = p;
		p = Parse(SymbolType_QUESTION, p);
		if (!p)
		{
			p = b;
			p = Parse(SymbolType_STAR, p);
			if (!p)
			{
				p = b;
				p = Parse(SymbolType_PLUS, p);
				if (!p)
				{
					p = b;
				}
			}
		}
	}
	r.first->second = p;
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Class(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	if (p->value == '[') ++p; else p = 0;
	if (p)
	{
		for (;;)
		{
			Node* b2 = p;
			size_t s2 = v.size();
			if (p->value == ']') ++p; else p = 0;
			if (p) p = 0; else p = b2;
			if (p)
			{
				p = Visit(SymbolType_Range, p, v);
			}
			if (!p)
			{
				p = b2;
				v.erase(v.begin() + s2, v.end());
				break;
			}
		}
		if (p)
		{
			if (p->value == ']') ++p; else p = 0;
			if (p)
			{
				p = Parse(SymbolType_Spacing, p);
			}
		}
	}
	b->end.insert(Memo(SymbolType_Class, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Definition(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Visit(SymbolType_Identifier, p, v);
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
		if (p)
		{
			p = Visit(SymbolType_LEFTARROW, p, v);
			if (p)
			{
				p = Visit(SymbolType_Expression, p, v);
			}
		}
	}
	b->end.insert(Memo(SymbolType_Definition, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Expression(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Visit(SymbolType_Sequence, p, v);
	if (p)
	{
		for (;;)
		{
			Node* b2 = p;
			size_t s2 = v.size();
			p = Parse(SymbolType_SLASH, p);
			if (p)
			{
				p = Visit(SymbolType_Sequence, p, v);
			}
			if (!p)
			{
				p = b2;
				v.erase(v.begin() + s2, v.end());
				break;
			}
		}
	}
	b->end.insert(Memo(SymbolType_Expression, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Grammar(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Parse(SymbolType_Spacing, p);
	if (p)
	{
		p = Visit(SymbolType_Definition, p, v);
		if (p)
		{
			for (;;)
			{
				Node* b2 = p;
				size_t s2 = v.size();
				p = Visit(SymbolType_Definition, p, v);
				if (!p)
				{
					p = b2;
					v.erase(v.begin() + s2, v.end());
					break;
				}
			}
			if (p)
			{
				p = Parse(SymbolType_EndOfFile, p);
			}
		}
	}
	b->end.insert(Memo(SymbolType_Grammar, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Literal(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	size_t s = v.size();
	if (p->value == '\'') ++p; else p = 0;
	if (p)
	{
		for (;;)
		{
			Node* b2 = p;
			size_t s2 = v.size();
			if (p->value == '\'') ++p; else p = 0;
			if (p) p = 0; else p = b2;
			if (p)
			{
				p = Visit(SymbolType_Char, p, v);
			}
			if (!p)
			{
				p = b2;
				v.erase(v.begin() + s2, v.end());
				break;
			}
		}
		if (p)
		{
			if (p->value == '\'') ++p; else p = 0;
			if (p)
			{
				p = Parse(SymbolType_Spacing, p);
			}
		}
	}
	if (!p)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		if (p->value == '\"') ++p; else p = 0;
		if (p)
		{
			for (;;)
			{
				Node* b3 = p;
				size_t s3 = v.size();
				if (p->value == '\"') ++p; else p = 0;
				if (p) p = 0; else p = b3;
				if (p)
				{
					p = Visit(SymbolType_Char, p, v);
				}
				if (!p)
				{
					p = b3;
					v.erase(v.begin() + s3, v.end());
					break;
				}
			}
			if (p)
			{
				if (p->value == '\"') ++p; else p = 0;
				if (p)
				{
					p = Parse(SymbolType_Spacing, p);
				}
			}
		}
	}
	b->end.insert(Memo(SymbolType_Literal, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Prefix(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Parse(SymbolType_AND, p);
	if (!p)
	{
		p = b;
		p = Parse(SymbolType_NOT, p);
		if (!p)
		{
			p = b;
		}
	}
	if (p)
	{
		p = Visit(SymbolType_Suffix, p, v);
	}
	b->end.insert(Memo(SymbolType_Prefix, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Primary(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	size_t s = v.size();
	p = Visit(SymbolType_Identifier, p, v);
	if (p)
	{
		p = Parse(SymbolType_Spacing, p);
		if (p)
		{
			Node* b2 = p;
			p = Parse(SymbolType_LEFTARROW, p);
			if (p) p = 0; else p = b2;
		}
	}
	if (!p)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		p = Parse(SymbolType_OPEN, p);
		if (p)
		{
			p = Visit(SymbolType_Expression, p, v);
			if (p)
			{
				p = Parse(SymbolType_CLOSE, p);
			}
		}
		if (!p)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			p = Visit(SymbolType_Literal, p, v);
			if (!p)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				p = Visit(SymbolType_Class, p, v);
				if (!p)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					p = Parse(SymbolType_DOT, p);
				}
			}
		}
	}
	b->end.insert(Memo(SymbolType_Primary, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Range(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Visit(SymbolType_Char, p, v);
	if (p)
	{
		Node* b2 = p;
		size_t s2 = v.size();
		if (p->value == '-') ++p; else p = 0;
		if (p)
		{
			p = Visit(SymbolType_Char, p, v);
		}
		if (!p)
		{
			p = b2;
			v.erase(v.begin() + s2, v.end());
		}
	}
	b->end.insert(Memo(SymbolType_Range, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Sequence(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	for (;;)
	{
		Node* b2 = p;
		size_t s2 = v.size();
		p = Visit(SymbolType_Prefix, p, v);
		if (!p)
		{
			p = b2;
			v.erase(v.begin() + s2, v.end());
			break;
		}
	}
	b->end.insert(Memo(SymbolType_Sequence, p));
	return p;
}

PEGParser::Node* PEGParser::Parser::Traverse_Suffix(PEGParser::Node* p, PEGParser::PTNodeChildren& v)
{
	Node* b = p;
	p = Visit(SymbolType_Primary, p, v);
	if (p)
	{
		Node* b2 = p;
		p = Parse(SymbolType_QUESTION, p);
		if (!p)
		{
			p = b2;
			p = Parse(SymbolType_STAR, p);
			if (!p)
			{
				p = b2;
				p = Parse(SymbolType_PLUS, p);
				if (!p)
				{
					p = b2;
				}
			}
		}
	}
	b->end.insert(Memo(SymbolType_Suffix, p));
	return p;
}

PEGParser::PTItr::PTItr(PEGParser::SymbolType _type, PEGParser::Node* _pNode)
:	mType(_type)
,	mpNode(_pNode)
, mpSiblings(new PTNodeChildren)
, mpParser(new Parser)
{
	if (mpNode && End())
		mpSiblings->push_back(PTNodeChild(mType, mpNode));

	miCurrent = mpSiblings->begin();
}

PEGParser::PTItr::PTItr(const PEGParser::PTItr& _iOther)
: mType(_iOther.mType)
,	mpNode(_iOther.mpNode)
, mpSiblings(_iOther.mpSiblings)
, miCurrent(_iOther.miCurrent)
,	mpParser(_iOther.mpParser)
{
}

PEGParser::PTItr::operator bool() const
{
	return mpNode != 0;
}

PEGParser::PTItr& PEGParser::PTItr::operator++()
{
	mpChildren.reset();
	GoToNext(mType);
	return *this;
}

PEGParser::SymbolType PEGParser::PTItr::GetType() const
{
	return mType;
}

PEGParser::Node* PEGParser::PTItr::Begin() const
{
	assert(mpNode);
	return mpNode;
}

PEGParser::Node* PEGParser::PTItr::End() const
{
	assert(mpNode);
	if (mType == SymbolType(0))
		return mpNode + 1;
	return mpParser->Parse(mType, mpNode);
}

PEGParser::PTItr PEGParser::PTItr::GetChild(PEGParser::SymbolType _childT)
{
	assert(mpNode != 0);
	if (_childT == SymbolType(0))
		return PTItr(SymbolType(0), mpNode);
	else
		return PTItr(mpParser, GetChildren(), _childT);
}

PEGParser::PTItr PEGParser::PTItr::GetNext(PEGParser::SymbolType _childT)
{
	assert(mpNode != 0);
	if (_childT == SymbolType(0))
		return PTItr(SymbolType(0), mpNode + 1);
	else
		return PTItr(*this, _childT);
}

PEGParser::PTItr::PTItr(boost::shared_ptr<PEGParser::Parser> _pParser, boost::shared_ptr<PEGParser::PTNodeChildren> _pSiblings, PEGParser::SymbolType _childType)
: mType(_childType)
, mpSiblings(_pSiblings)
, miCurrent(_pSiblings->begin())
,	mpParser(_pParser)
{
	SkipSiblingsWithWrongType(_childType);
}

PEGParser::PTItr::PTItr(const PEGParser::PTItr& _iOther, PEGParser::SymbolType _childType)
: mType(_childType)
,	mpSiblings(_iOther.mpSiblings)
,	miCurrent(_iOther.miCurrent)
,	mpParser(_iOther.mpParser)
{
	SkipSiblingsWithWrongType(_childType);
}

void PEGParser::PTItr::GoToNext(PEGParser::SymbolType _childType)
{
	if (mType == SymbolType(0))
	{
		++mpNode;
		if (mpNode->value == 0)
			mpNode = 0;
	}
	else
	{
		++miCurrent;
		SkipSiblingsWithWrongType(_childType);
	}
}

void PEGParser::PTItr::SkipSiblingsWithWrongType(PEGParser::SymbolType _childType)
{
	assert(_childType != SymbolType(0));
	PTNodeChildren::iterator iEnd = mpSiblings->end();
	while (miCurrent != iEnd && miCurrent->first != _childType)
		++miCurrent;
	mpNode = (miCurrent != iEnd) ? miCurrent->second : 0 ;
}

boost::shared_ptr<PEGParser::PTNodeChildren> PEGParser::PTItr::GetChildren()
{
	if (!mpChildren)
	{
		PTNodeChildren children;
		mpParser->Traverse(mType, mpNode, children);
		mpChildren.reset(new PTNodeChildren);
		mpChildren->swap(children);			
	}
	return mpChildren;
}

std::ostream& PEGParser::operator<<(std::ostream& _os, const PEGParser::PTItr& _i)
{
	if (_i)
	{
		for (const PEGParser::Node *p = _i.Begin(), *pEnd = _i.End(); p != pEnd; ++p)
			_os.put(p->value);
	}
	return _os;
}

