// This file was automatically generated by IPG on Fri Sep  2 09:53:41 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#ifndef BOOTSTRAP_TEST
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <boost/format.hpp>
#include <tr1/unordered_map>
#include <tr1/unordered_set>
#endif

#ifndef BOOTSTRAP_TEST
#include <vector>
#include <boost/shared_ptr.hpp>
#endif

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_CLASS,
		SymbolType_CLASS_1,
		SymbolType_Char,
		SymbolType_Definition,
		SymbolType_Expression,
		SymbolType_Expression_1,
		SymbolType_Grammar,
		SymbolType_Grammar_1,
		SymbolType_IDENTIFIER_1,
		SymbolType_Identifier,
		SymbolType_Item,
		SymbolType_Item_1,
		SymbolType_Item_2,
		SymbolType_LEFTARROW,
		SymbolType_LITERAL,
		SymbolType_LITERAL_1,
		SymbolType_Primary,
		SymbolType_Primary_1,
		SymbolType_Primary_2,
		SymbolType_Primary_3,
		SymbolType_Range,
		SymbolType_Sequence,
		SymbolTypeInvalid,
		SymbolTypeCount = SymbolTypeInvalid
	};

	struct Symbol
	{
		SymbolType type;
		size_t length;
		const char* value;
	};

	const char* SymbolName(SymbolType _type);

	class Context;

	class Iterator
	{
	public:
		friend Iterator Traverse(SymbolType _type, const char* _text);
		friend Iterator Traverse(const Iterator& _iParent);
		friend void DebugPrint(std::ostream& _os, const Iterator& _i, int _tabs, int _maxLineSize);

		Iterator();
		Iterator& operator++();
		const Symbol& operator*() const;
		const Symbol* operator->() const;

	private:
		Iterator(boost::shared_ptr<Context> _pContext, boost::shared_ptr< std::vector<Symbol> > _pSiblings);

		boost::shared_ptr<Context> mpContext;
		boost::shared_ptr< std::vector<Symbol> > mpSiblings;
		std::vector<Symbol>::iterator mi;
	};

	Iterator Traverse(SymbolType _type, const char* _text);
	Iterator Traverse(const Iterator& _iParent);
	void DebugPrint(std::ostream& _os, const Iterator& _i, int _tabs = 0, int _maxLineSize = 100);
}

using namespace std;
using namespace std::tr1;
using namespace boost;
using namespace PEGParser;

namespace
{
	struct Memo
	{
		unordered_map<const char*, const char*> end;
		unordered_set<const char*> fail;
	};
	struct EscapeChar
	{
		EscapeChar(char _c);
		char c;
	};

	EscapeChar::EscapeChar(char _c) : c(_c)
	{
	}

	ostream& operator<<(ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\n': c = 'n'; break;
			case '\r': c = 'r'; break;
			case '\t': c = 't'; break;

			case '\\':
			case '\'':
			case '\"':
				break;

			default:
				_os.put(c);
				return _os;
		}

		_os.put('\\');
		_os.put(c);
		return _os;
	}

	bool ParseSymbol(Context&, SymbolType, const char*&);

	typedef bool ParseFn(Context&, const char*&);
	ParseFn Parse_AND, Parse_CLASS, Parse_CLASS_1, Parse_CLOSE, Parse_Char, Parse_Comment, Parse_DOT, Parse_Definition, Parse_EndOfFile, Parse_EndOfLine, Parse_Expression, Parse_Expression_1, Parse_Grammar, Parse_Grammar_1, Parse_IDENTIFIER, Parse_IDENTIFIER_1, Parse_Identifier, Parse_Item, Parse_Item_1, Parse_Item_2, Parse_LEFTARROW, Parse_LITERAL, Parse_LITERAL_1, Parse_NOT, Parse_OPEN, Parse_PLUS, Parse_Primary, Parse_Primary_1, Parse_Primary_2, Parse_Primary_3, Parse_QUESTION, Parse_Range, Parse_SLASH, Parse_STAR, Parse_Sequence, Parse_Space, Parse_Spacing;

	typedef bool TraverseFn(Context&, const char*&, vector<Symbol>&);
	TraverseFn Traverse_AND, Traverse_CLASS, Traverse_CLASS_1, Traverse_CLOSE, Traverse_Char, Traverse_Comment, Traverse_DOT, Traverse_Definition, Traverse_EndOfFile, Traverse_EndOfLine, Traverse_Expression, Traverse_Expression_1, Traverse_Grammar, Traverse_Grammar_1, Traverse_IDENTIFIER, Traverse_IDENTIFIER_1, Traverse_Identifier, Traverse_Item, Traverse_Item_1, Traverse_Item_2, Traverse_LEFTARROW, Traverse_LITERAL, Traverse_LITERAL_1, Traverse_NOT, Traverse_OPEN, Traverse_PLUS, Traverse_Primary, Traverse_Primary_1, Traverse_Primary_2, Traverse_Primary_3, Traverse_QUESTION, Traverse_Range, Traverse_SLASH, Traverse_STAR, Traverse_Sequence, Traverse_Space, Traverse_Spacing;
}

const char* PEGParser::SymbolName(SymbolType _type)
{
	switch (_type)
	{
		case SymbolType_CLASS: return "CLASS";
		case SymbolType_CLASS_1: return "CLASS_1";
		case SymbolType_Char: return "Char";
		case SymbolType_Definition: return "Definition";
		case SymbolType_Expression: return "Expression";
		case SymbolType_Expression_1: return "Expression_1";
		case SymbolType_Grammar: return "Grammar";
		case SymbolType_Grammar_1: return "Grammar_1";
		case SymbolType_IDENTIFIER_1: return "IDENTIFIER_1";
		case SymbolType_Identifier: return "Identifier";
		case SymbolType_Item: return "Item";
		case SymbolType_Item_1: return "Item_1";
		case SymbolType_Item_2: return "Item_2";
		case SymbolType_LEFTARROW: return "LEFTARROW";
		case SymbolType_LITERAL: return "LITERAL";
		case SymbolType_LITERAL_1: return "LITERAL_1";
		case SymbolType_Primary: return "Primary";
		case SymbolType_Primary_1: return "Primary_1";
		case SymbolType_Primary_2: return "Primary_2";
		case SymbolType_Primary_3: return "Primary_3";
		case SymbolType_Range: return "Range";
		case SymbolType_Sequence: return "Sequence";
		default: throw runtime_error(str(format("Invalid Symbol Type: %1%") % _type));
	}
}

class PEGParser::Context
{
public:
	Memo memos[SymbolTypeCount];
};

namespace
{
	bool Visit(Context& _ctx, SymbolType _type, const char*& _p, vector<Symbol>& _v)
	{
		const char* pBegin = _p;
		bool r = ParseSymbol(_ctx, _type, _p);
		if (r)
		{
			Symbol symbol = { _type, _p - pBegin, pBegin };
			_v.push_back(symbol);
		}
		return r;
	}

	bool ParseMemoized(Context& _ctx, Memo& _memo, ParseFn* _parseFn, const char*& p)
	{
		if (_memo.fail.count(p))
			return false;

		unordered_map<const char*, const char*>::iterator i = _memo.end.find(p);
		if (i != _memo.end.end())
		{
			p = i->second;
			return true;
		}

		const char* pBegin = p;
		if (_parseFn(_ctx, p))
		{
			_memo.end[pBegin] = p;
			return true;
		}

		_memo.fail.insert(pBegin);
		return false;
	}
	bool ParseSymbol(Context& _ctx, SymbolType _type, const char*& p)
	{
		assert(_type >= 0 && _type < SymbolTypeCount);
		switch (_type)
		{
			case SymbolType_CLASS: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_CLASS, p);
			case SymbolType_CLASS_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_CLASS_1, p);
			case SymbolType_Char: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Char, p);
			case SymbolType_Definition: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Definition, p);
			case SymbolType_Expression: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Expression, p);
			case SymbolType_Expression_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Expression_1, p);
			case SymbolType_Grammar: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Grammar, p);
			case SymbolType_Grammar_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Grammar_1, p);
			case SymbolType_IDENTIFIER_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_IDENTIFIER_1, p);
			case SymbolType_Identifier: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Identifier, p);
			case SymbolType_Item: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Item, p);
			case SymbolType_Item_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Item_1, p);
			case SymbolType_Item_2: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Item_2, p);
			case SymbolType_LEFTARROW: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_LEFTARROW, p);
			case SymbolType_LITERAL: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_LITERAL, p);
			case SymbolType_LITERAL_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_LITERAL_1, p);
			case SymbolType_Primary: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Primary, p);
			case SymbolType_Primary_1: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Primary_1, p);
			case SymbolType_Primary_2: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Primary_2, p);
			case SymbolType_Primary_3: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Primary_3, p);
			case SymbolType_Range: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Range, p);
			case SymbolType_Sequence: return ParseMemoized(_ctx, _ctx.memos[_type], Parse_Sequence, p);
			default:
				assert(false);
				return false;
		}
	}

	bool Parse_AND(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '&');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_CLASS(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '[');
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				char c1 = *p++;
				r = (c1 == ']');
				r = !r;
				p = b;
				if (r)
				{
					r = ParseSymbol(_ctx, SymbolType_Range, p);
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				r = ParseSymbol(_ctx, SymbolType_CLASS_1, p);
			}
		}
		return r;
	}

	bool Parse_CLASS_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == ']');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_CLOSE(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == ')');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_Char(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == '\\');
		if (r)
		{
			const char* b2 = p;
			char c1 = *p++;
			r = (c1 == 'n');
			if (!r)
			{
				p = b2;
				char c2 = *p++;
				r = (c2 == 'r');
				if (!r)
				{
					p = b2;
					char c3 = *p++;
					r = (c3 == 't');
					if (!r)
					{
						p = b2;
						char c4 = *p++;
						r = (c4 == '\'');
						if (!r)
						{
							p = b2;
							char c5 = *p++;
							r = (c5 == '\"');
							if (!r)
							{
								p = b2;
								char c6 = *p++;
								r = (c6 == '[');
								if (!r)
								{
									p = b2;
									char c7 = *p++;
									r = (c7 == ']');
									if (!r)
									{
										p = b2;
										char c8 = *p++;
										r = (c8 == '\\');
										if (!r)
										{
											p = b2;
											char c9 = *p++;
											r = (c9 >= '1' && c9 <= '9');
											if (r)
											{
												for (;;)
												{
													const char* b3 = p;
													char c10 = *p++;
													r = (c10 >= '0' && c10 <= '9');
													if (!r)
													{
														p = b3;
														break;
													}
												}
												r = true;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			char c11 = *p++;
			r = (c11 == '\\');
			r = !r;
			p = b;
			if (r)
			{
				char c12 = *p++;
				r = (c12 != 0);
			}
		}
		return r;
	}

	bool Parse_Comment(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '#');
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				r = Parse_EndOfLine(_ctx, p);
				r = !r;
				p = b;
				if (r)
				{
					char c1 = *p++;
					r = (c1 != 0);
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				r = Parse_EndOfLine(_ctx, p);
			}
		}
		return r;
	}

	bool Parse_DOT(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '.');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_Definition(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_IDENTIFIER(_ctx, p);
		if (r)
		{
			r = ParseSymbol(_ctx, SymbolType_LEFTARROW, p);
			if (r)
			{
				r = ParseSymbol(_ctx, SymbolType_Expression, p);
			}
		}
		return r;
	}

	bool Parse_EndOfFile(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 != 0);
		r = !r;
		p = b;
		return r;
	}

	bool Parse_EndOfLine(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == '\n');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 == '\r');
			if (r)
			{
				const char* b2 = p;
				char c2 = *p++;
				r = (c2 == '\n');
				if (!r)
				{
					p = b2;
					r = true;
				}
			}
		}
		return r;
	}

	bool Parse_Expression(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = ParseSymbol(_ctx, SymbolType_Sequence, p);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				r = ParseSymbol(_ctx, SymbolType_Expression_1, p);
				if (r)
				{
					r = ParseSymbol(_ctx, SymbolType_Sequence, p);
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
		}
		return r;
	}

	bool Parse_Expression_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_SLASH(_ctx, p);
		return r;
	}

	bool Parse_Grammar(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = ParseSymbol(_ctx, SymbolType_Grammar_1, p);
		if (r)
		{
			r = ParseSymbol(_ctx, SymbolType_Definition, p);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					r = ParseSymbol(_ctx, SymbolType_Definition, p);
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
				if (r)
				{
					r = Parse_EndOfFile(_ctx, p);
				}
			}
		}
		return r;
	}

	bool Parse_Grammar_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_Spacing(_ctx, p);
		return r;
	}

	bool Parse_IDENTIFIER(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = ParseSymbol(_ctx, SymbolType_Identifier, p);
		if (r)
		{
			r = ParseSymbol(_ctx, SymbolType_IDENTIFIER_1, p);
		}
		return r;
	}

	bool Parse_IDENTIFIER_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_Spacing(_ctx, p);
		return r;
	}

	bool Parse_Identifier(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 >= 'a' && c0 <= 'z');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 >= 'A' && c1 <= 'Z');
			if (!r)
			{
				p = b;
				char c2 = *p++;
				r = (c2 == '_');
			}
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				char c3 = *p++;
				r = (c3 >= 'a' && c3 <= 'z');
				if (!r)
				{
					p = b2;
					char c4 = *p++;
					r = (c4 >= 'A' && c4 <= 'Z');
					if (!r)
					{
						p = b2;
						char c5 = *p++;
						r = (c5 >= '0' && c5 <= '9');
						if (!r)
						{
							p = b2;
							char c6 = *p++;
							r = (c6 == '_');
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
		return r;
	}

	bool Parse_Item(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = ParseSymbol(_ctx, SymbolType_Item_1, p);
		if (r)
		{
			r = ParseSymbol(_ctx, SymbolType_Primary, p);
			if (r)
			{
				r = ParseSymbol(_ctx, SymbolType_Item_2, p);
			}
		}
		return r;
	}

	bool Parse_Item_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		r = Parse_AND(_ctx, p);
		if (!r)
		{
			p = b;
			r = Parse_NOT(_ctx, p);
			if (!r)
			{
				p = b;
				r = true;
			}
		}
		return r;
	}

	bool Parse_Item_2(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		r = Parse_QUESTION(_ctx, p);
		if (!r)
		{
			p = b;
			r = Parse_STAR(_ctx, p);
			if (!r)
			{
				p = b;
				r = Parse_PLUS(_ctx, p);
				if (!r)
				{
					p = b;
					r = true;
				}
			}
		}
		return r;
	}

	bool Parse_LEFTARROW(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '<');
		if (r)
		{
			const char* b = p;
			char c1 = *p++;
			r = (c1 == '-');
			if (!r)
			{
				p = b;
				char c2 = *p++;
				r = (c2 == '=');
			}
			if (r)
			{
				r = Parse_Spacing(_ctx, p);
			}
		}
		return r;
	}

	bool Parse_LITERAL(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == '\'');
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				char c1 = *p++;
				r = (c1 == '\'');
				r = !r;
				p = b2;
				if (r)
				{
					r = ParseSymbol(_ctx, SymbolType_Char, p);
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
			if (r)
			{
				char c2 = *p++;
				r = (c2 == '\'');
			}
		}
		if (!r)
		{
			p = b;
			char c3 = *p++;
			r = (c3 == '\"');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					char c4 = *p++;
					r = (c4 == '\"');
					r = !r;
					p = b3;
					if (r)
					{
						r = ParseSymbol(_ctx, SymbolType_Char, p);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					char c5 = *p++;
					r = (c5 == '\"');
				}
			}
		}
		if (r)
		{
			r = ParseSymbol(_ctx, SymbolType_LITERAL_1, p);
		}
		return r;
	}

	bool Parse_LITERAL_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_Spacing(_ctx, p);
		return r;
	}

	bool Parse_NOT(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '!');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_OPEN(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '(');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_PLUS(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '+');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_Primary(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		r = Parse_IDENTIFIER(_ctx, p);
		if (r)
		{
			const char* b2 = p;
			r = ParseSymbol(_ctx, SymbolType_LEFTARROW, p);
			r = !r;
			p = b2;
		}
		if (!r)
		{
			p = b;
			r = ParseSymbol(_ctx, SymbolType_Primary_1, p);
			if (r)
			{
				r = ParseSymbol(_ctx, SymbolType_Expression, p);
				if (r)
				{
					r = ParseSymbol(_ctx, SymbolType_Primary_2, p);
				}
			}
			if (!r)
			{
				p = b;
				r = ParseSymbol(_ctx, SymbolType_LITERAL, p);
				if (!r)
				{
					p = b;
					r = ParseSymbol(_ctx, SymbolType_CLASS, p);
					if (!r)
					{
						p = b;
						r = ParseSymbol(_ctx, SymbolType_Primary_3, p);
					}
				}
			}
		}
		return r;
	}

	bool Parse_Primary_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_OPEN(_ctx, p);
		return r;
	}

	bool Parse_Primary_2(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_CLOSE(_ctx, p);
		return r;
	}

	bool Parse_Primary_3(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = Parse_DOT(_ctx, p);
		return r;
	}

	bool Parse_QUESTION(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '?');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_Range(Context& _ctx, const char*& p)
	{
		bool r = true;
		r = ParseSymbol(_ctx, SymbolType_Char, p);
		if (r)
		{
			const char* b = p;
			char c0 = *p++;
			r = (c0 == '-');
			if (r)
			{
				r = ParseSymbol(_ctx, SymbolType_Char, p);
			}
			if (!r)
			{
				p = b;
				r = true;
			}
		}
		return r;
	}

	bool Parse_SLASH(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '/');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_STAR(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '*');
		if (r)
		{
			r = Parse_Spacing(_ctx, p);
		}
		return r;
	}

	bool Parse_Sequence(Context& _ctx, const char*& p)
	{
		bool r = true;
		for (;;)
		{
			const char* b = p;
			r = ParseSymbol(_ctx, SymbolType_Item, p);
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
		return r;
	}

	bool Parse_Space(Context& _ctx, const char*& p)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == ' ');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 == '\t');
			if (!r)
			{
				p = b;
				r = Parse_EndOfLine(_ctx, p);
			}
		}
		return r;
	}

	bool Parse_Spacing(Context& _ctx, const char*& p)
	{
		bool r = true;
		for (;;)
		{
			const char* b = p;
			r = Parse_Space(_ctx, p);
			if (!r)
			{
				p = b;
				r = Parse_Comment(_ctx, p);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
		return r;
	}

	bool TraverseSymbol(Context& _ctx, SymbolType _type, const char*& p, vector<Symbol>& v)
	{
		const char* pBegin = p;
		if (_ctx.memos[_type].fail.count(pBegin))
			return false;

		bool r = true;
		switch (_type)
		{
			case SymbolType_CLASS: r = Traverse_CLASS(_ctx, p, v); break;
			case SymbolType_CLASS_1: r = Traverse_CLASS_1(_ctx, p, v); break;
			case SymbolType_Char: r = Traverse_Char(_ctx, p, v); break;
			case SymbolType_Definition: r = Traverse_Definition(_ctx, p, v); break;
			case SymbolType_Expression: r = Traverse_Expression(_ctx, p, v); break;
			case SymbolType_Expression_1: r = Traverse_Expression_1(_ctx, p, v); break;
			case SymbolType_Grammar: r = Traverse_Grammar(_ctx, p, v); break;
			case SymbolType_Grammar_1: r = Traverse_Grammar_1(_ctx, p, v); break;
			case SymbolType_IDENTIFIER_1: r = Traverse_IDENTIFIER_1(_ctx, p, v); break;
			case SymbolType_Identifier: r = Traverse_Identifier(_ctx, p, v); break;
			case SymbolType_Item: r = Traverse_Item(_ctx, p, v); break;
			case SymbolType_Item_1: r = Traverse_Item_1(_ctx, p, v); break;
			case SymbolType_Item_2: r = Traverse_Item_2(_ctx, p, v); break;
			case SymbolType_LEFTARROW: r = Traverse_LEFTARROW(_ctx, p, v); break;
			case SymbolType_LITERAL: r = Traverse_LITERAL(_ctx, p, v); break;
			case SymbolType_LITERAL_1: r = Traverse_LITERAL_1(_ctx, p, v); break;
			case SymbolType_Primary: r = Traverse_Primary(_ctx, p, v); break;
			case SymbolType_Primary_1: r = Traverse_Primary_1(_ctx, p, v); break;
			case SymbolType_Primary_2: r = Traverse_Primary_2(_ctx, p, v); break;
			case SymbolType_Primary_3: r = Traverse_Primary_3(_ctx, p, v); break;
			case SymbolType_Range: r = Traverse_Range(_ctx, p, v); break;
			case SymbolType_Sequence: r = Traverse_Sequence(_ctx, p, v); break;
			default:
				assert(false);
				return false;
		}

		if (r)
			_ctx.memos[_type].end[pBegin] = p;
		else
			_ctx.memos[_type].fail.insert(pBegin);
		return r;
	}
	bool Traverse_AND(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '&');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_CLASS(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '[');
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				size_t s = v.size();
				char c1 = *p++;
				r = (c1 == ']');
				r = !r;
				p = b;
				if (r)
				{
					r = Visit(_ctx, SymbolType_Range, p, v);
				}
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				r = TraverseSymbol(_ctx, SymbolType_CLASS_1, p, v);
			}
		}
		return r;
	}

	bool Traverse_CLASS_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == ']');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_CLOSE(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == ')');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_Char(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == '\\');
		if (r)
		{
			const char* b2 = p;
			char c1 = *p++;
			r = (c1 == 'n');
			if (!r)
			{
				p = b2;
				char c2 = *p++;
				r = (c2 == 'r');
				if (!r)
				{
					p = b2;
					char c3 = *p++;
					r = (c3 == 't');
					if (!r)
					{
						p = b2;
						char c4 = *p++;
						r = (c4 == '\'');
						if (!r)
						{
							p = b2;
							char c5 = *p++;
							r = (c5 == '\"');
							if (!r)
							{
								p = b2;
								char c6 = *p++;
								r = (c6 == '[');
								if (!r)
								{
									p = b2;
									char c7 = *p++;
									r = (c7 == ']');
									if (!r)
									{
										p = b2;
										char c8 = *p++;
										r = (c8 == '\\');
										if (!r)
										{
											p = b2;
											char c9 = *p++;
											r = (c9 >= '1' && c9 <= '9');
											if (r)
											{
												for (;;)
												{
													const char* b3 = p;
													char c10 = *p++;
													r = (c10 >= '0' && c10 <= '9');
													if (!r)
													{
														p = b3;
														break;
													}
												}
												r = true;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			char c11 = *p++;
			r = (c11 == '\\');
			r = !r;
			p = b;
			if (r)
			{
				char c12 = *p++;
				r = (c12 != 0);
			}
		}
		return r;
	}

	bool Traverse_Comment(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '#');
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				r = Parse_EndOfLine(_ctx, p);
				r = !r;
				p = b;
				if (r)
				{
					char c1 = *p++;
					r = (c1 != 0);
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				r = Traverse_EndOfLine(_ctx, p, v);
			}
		}
		return r;
	}

	bool Traverse_DOT(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '.');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_Definition(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_IDENTIFIER(_ctx, p, v);
		if (r)
		{
			r = Visit(_ctx, SymbolType_LEFTARROW, p, v);
			if (r)
			{
				r = Visit(_ctx, SymbolType_Expression, p, v);
			}
		}
		return r;
	}

	bool Traverse_EndOfFile(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 != 0);
		r = !r;
		p = b;
		return r;
	}

	bool Traverse_EndOfLine(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == '\n');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 == '\r');
			if (r)
			{
				const char* b2 = p;
				char c2 = *p++;
				r = (c2 == '\n');
				if (!r)
				{
					p = b2;
					r = true;
				}
			}
		}
		return r;
	}

	bool Traverse_Expression(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Visit(_ctx, SymbolType_Sequence, p, v);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				size_t s = v.size();
				r = TraverseSymbol(_ctx, SymbolType_Expression_1, p, v);
				if (r)
				{
					r = Visit(_ctx, SymbolType_Sequence, p, v);
				}
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			r = true;
		}
		return r;
	}

	bool Traverse_Expression_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_SLASH(_ctx, p, v);
		return r;
	}

	bool Traverse_Grammar(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = TraverseSymbol(_ctx, SymbolType_Grammar_1, p, v);
		if (r)
		{
			r = Visit(_ctx, SymbolType_Definition, p, v);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					size_t s = v.size();
					r = Visit(_ctx, SymbolType_Definition, p, v);
					if (!r)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						break;
					}
				}
				r = true;
				if (r)
				{
					r = Traverse_EndOfFile(_ctx, p, v);
				}
			}
		}
		return r;
	}

	bool Traverse_Grammar_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_Spacing(_ctx, p, v);
		return r;
	}

	bool Traverse_IDENTIFIER(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Visit(_ctx, SymbolType_Identifier, p, v);
		if (r)
		{
			r = TraverseSymbol(_ctx, SymbolType_IDENTIFIER_1, p, v);
		}
		return r;
	}

	bool Traverse_IDENTIFIER_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_Spacing(_ctx, p, v);
		return r;
	}

	bool Traverse_Identifier(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 >= 'a' && c0 <= 'z');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 >= 'A' && c1 <= 'Z');
			if (!r)
			{
				p = b;
				char c2 = *p++;
				r = (c2 == '_');
			}
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				char c3 = *p++;
				r = (c3 >= 'a' && c3 <= 'z');
				if (!r)
				{
					p = b2;
					char c4 = *p++;
					r = (c4 >= 'A' && c4 <= 'Z');
					if (!r)
					{
						p = b2;
						char c5 = *p++;
						r = (c5 >= '0' && c5 <= '9');
						if (!r)
						{
							p = b2;
							char c6 = *p++;
							r = (c6 == '_');
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
		return r;
	}

	bool Traverse_Item(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = TraverseSymbol(_ctx, SymbolType_Item_1, p, v);
		if (r)
		{
			r = Visit(_ctx, SymbolType_Primary, p, v);
			if (r)
			{
				r = TraverseSymbol(_ctx, SymbolType_Item_2, p, v);
			}
		}
		return r;
	}

	bool Traverse_Item_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		r = Traverse_AND(_ctx, p, v);
		if (!r)
		{
			p = b;
			r = Traverse_NOT(_ctx, p, v);
			if (!r)
			{
				p = b;
				r = true;
			}
		}
		return r;
	}

	bool Traverse_Item_2(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		r = Traverse_QUESTION(_ctx, p, v);
		if (!r)
		{
			p = b;
			r = Traverse_STAR(_ctx, p, v);
			if (!r)
			{
				p = b;
				r = Traverse_PLUS(_ctx, p, v);
				if (!r)
				{
					p = b;
					r = true;
				}
			}
		}
		return r;
	}

	bool Traverse_LEFTARROW(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '<');
		if (r)
		{
			const char* b = p;
			char c1 = *p++;
			r = (c1 == '-');
			if (!r)
			{
				p = b;
				char c2 = *p++;
				r = (c2 == '=');
			}
			if (r)
			{
				r = Traverse_Spacing(_ctx, p, v);
			}
		}
		return r;
	}

	bool Traverse_LITERAL(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		size_t s = v.size();
		char c0 = *p++;
		r = (c0 == '\'');
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				size_t s2 = v.size();
				char c1 = *p++;
				r = (c1 == '\'');
				r = !r;
				p = b2;
				if (r)
				{
					r = Visit(_ctx, SymbolType_Char, p, v);
				}
				if (!r)
				{
					p = b2;
					v.erase(v.begin() + s2, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				char c2 = *p++;
				r = (c2 == '\'');
			}
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			char c3 = *p++;
			r = (c3 == '\"');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					size_t s3 = v.size();
					char c4 = *p++;
					r = (c4 == '\"');
					r = !r;
					p = b3;
					if (r)
					{
						r = Visit(_ctx, SymbolType_Char, p, v);
					}
					if (!r)
					{
						p = b3;
						v.erase(v.begin() + s3, v.end());
						break;
					}
				}
				r = true;
				if (r)
				{
					char c5 = *p++;
					r = (c5 == '\"');
				}
			}
		}
		if (r)
		{
			r = TraverseSymbol(_ctx, SymbolType_LITERAL_1, p, v);
		}
		return r;
	}

	bool Traverse_LITERAL_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_Spacing(_ctx, p, v);
		return r;
	}

	bool Traverse_NOT(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '!');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_OPEN(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '(');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_PLUS(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '+');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_Primary(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		size_t s = v.size();
		r = Traverse_IDENTIFIER(_ctx, p, v);
		if (r)
		{
			const char* b2 = p;
			r = ParseSymbol(_ctx, SymbolType_LEFTARROW, p);
			r = !r;
			p = b2;
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			r = TraverseSymbol(_ctx, SymbolType_Primary_1, p, v);
			if (r)
			{
				r = Visit(_ctx, SymbolType_Expression, p, v);
				if (r)
				{
					r = TraverseSymbol(_ctx, SymbolType_Primary_2, p, v);
				}
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				r = Visit(_ctx, SymbolType_LITERAL, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					r = Visit(_ctx, SymbolType_CLASS, p, v);
					if (!r)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						r = TraverseSymbol(_ctx, SymbolType_Primary_3, p, v);
					}
				}
			}
		}
		return r;
	}

	bool Traverse_Primary_1(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_OPEN(_ctx, p, v);
		return r;
	}

	bool Traverse_Primary_2(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_CLOSE(_ctx, p, v);
		return r;
	}

	bool Traverse_Primary_3(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Traverse_DOT(_ctx, p, v);
		return r;
	}

	bool Traverse_QUESTION(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '?');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_Range(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		r = Visit(_ctx, SymbolType_Char, p, v);
		if (r)
		{
			const char* b = p;
			size_t s = v.size();
			char c0 = *p++;
			r = (c0 == '-');
			if (r)
			{
				r = Visit(_ctx, SymbolType_Char, p, v);
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				r = true;
			}
		}
		return r;
	}

	bool Traverse_SLASH(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '/');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_STAR(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		char c0 = *p++;
		r = (c0 == '*');
		if (r)
		{
			r = Traverse_Spacing(_ctx, p, v);
		}
		return r;
	}

	bool Traverse_Sequence(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		for (;;)
		{
			const char* b = p;
			size_t s = v.size();
			r = Visit(_ctx, SymbolType_Item, p, v);
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				break;
			}
		}
		r = true;
		return r;
	}

	bool Traverse_Space(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		const char* b = p;
		char c0 = *p++;
		r = (c0 == ' ');
		if (!r)
		{
			p = b;
			char c1 = *p++;
			r = (c1 == '\t');
			if (!r)
			{
				p = b;
				r = Traverse_EndOfLine(_ctx, p, v);
			}
		}
		return r;
	}

	bool Traverse_Spacing(Context& _ctx, const char*& p, vector<Symbol>& v)
	{
		bool r = true;
		for (;;)
		{
			const char* b = p;
			r = Traverse_Space(_ctx, p, v);
			if (!r)
			{
				p = b;
				r = Traverse_Comment(_ctx, p, v);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
		return r;
	}

	void DebugPrint(ostream& _os, Context& _ctx, SymbolType _type, const char* _pNode, int _tabs, int _maxLineSize)
	{
		vector<Symbol> children;
		const char* pEnd = _pNode;
		if (!TraverseSymbol(_ctx, _type, pEnd, children))
			throw runtime_error(str(format("Parsing Failed for \"%1%\"") % SymbolName(_type)));

		int tabCount = _tabs;
		while (tabCount--)
			_os << "    ";

		_os << SymbolName(_type) << ": \"";

		size_t lineSize = 0;
		for (const char* p = _pNode; p != pEnd; ++p)
		{
			_os << EscapeChar(*p);
			if (++lineSize >= _maxLineSize)
			{
				_os << "...";
				break;
			}
		}

		_os << "\"\n";

		for (vector<Symbol>::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
			DebugPrint(_os, _ctx, i->type, i->value, _tabs + 1, _maxLineSize);
	//*
		if (_tabs == 0)
		{
			_os << "Memo Count:\n";
			for (size_t k = 0; k < SymbolTypeCount; ++k)
				_os << boost::format("%1% %|20t|End: %2% %|40t|Fail: %3%\n") % SymbolName(SymbolType(k)) % _ctx.memos[k].end.size() % _ctx.memos[k].fail.size();
		}
	//*/
	}
}

PEGParser::Iterator::Iterator()
{
}

Iterator& PEGParser::Iterator::operator++()
{
	assert(mpSiblings);
	if (++mi == mpSiblings->end())
		mpSiblings.reset();
	return *this;
}

const Symbol& PEGParser::Iterator::operator*() const
{
	static const Symbol invalidSymbol = { SymbolTypeInvalid };
	if (mpSiblings)
		return *mi;
	else
		return invalidSymbol;
}

const Symbol* PEGParser::Iterator::operator->() const
{
	return &**this;
}

PEGParser::Iterator::Iterator(shared_ptr<Context> _pContext, shared_ptr< vector<Symbol> > _pSiblings)
: mpContext(_pContext)
, mpSiblings(_pSiblings)
{
	if (_pSiblings)
		mi = _pSiblings->begin();
}

Iterator PEGParser::Traverse(SymbolType _type, const char* _text)
{
	shared_ptr<Context> pContext(new Context);
	const char* p = _text;
	if (ParseSymbol(*pContext, _type, p))
	{
		Symbol symbol = { _type, p - _text, _text };
		shared_ptr< vector<Symbol> > pSymbols(new vector<Symbol>(1, symbol));
		return Iterator(pContext, pSymbols);
	}
	return Iterator();
}

Iterator PEGParser::Traverse(const Iterator& _iParent)
{
	if (_iParent.mpSiblings)
	{
		const Symbol& symbol = *_iParent.mi;
		const char* p = symbol.value;
		vector<Symbol> children;
		bool r = TraverseSymbol(*_iParent.mpContext, symbol.type, p, children);
		assert(r && p == symbol.value + symbol.length);
		boost::shared_ptr< vector<Symbol> > pChildren;
		if (!children.empty())
		{
			pChildren.reset(new vector<Symbol>);
			pChildren->swap(children);
		}
		return Iterator(_iParent.mpContext, pChildren);
	}
	return Iterator();
}

void PEGParser::DebugPrint(ostream& _os, const Iterator& _i, int _tabs, int _maxLineSize)
{
	if (_i.mpSiblings)
		::DebugPrint(_os, *_i.mpContext, _i.mi->type, _i.mi->value, _tabs, _maxLineSize);
}

