// This file was automatically generated by IPG
// DO NOT EDIT!
#include "PEGParser.h"

#include <ostream>
#include <iomanip>

using namespace PEGParser;

namespace
{
	typedef PTNodeTypeToPtr::value_type MemoEntry;
	typedef std::pair<PTNodeTypeToPtr::iterator, bool> MemoInsertResult;

	struct EscapeChar
	{
		EscapeChar(char _c) : c(_c) {}
		char c;
	};

	inline std::ostream& operator<<(std::ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\\': c = '\\'; break;
			case '\n': c = 'n';  break;
			case '\r': c = 'r';  break;
			case '\t': c = 't';  break;
			case '\'': c = '\''; break;
			case '\"': c = '\"'; break;
			default:
				_os.put(c);
				return _os;
		}
		_os.put('\\');
		_os.put(c);
		return _os;
	}

	struct Private
	{
		static Node* Parse_AND(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_AND, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '&') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_CLOSE(Node* p0)
		{
			p0 = (p0->value == ')') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p0;
		}

		static Node* Parse_Char(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Char, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = (p1->value == '\\') ? p1+1 : 0;
			if (p0)
			{
				Node* p2 = p0;
				p0 = (p2->value == 'n') ? p2+1 : 0;
				if (!p0)
				{
					p0 = (p2->value == 'r') ? p2+1 : 0;
					if (!p0)
					{
						p0 = (p2->value == 't') ? p2+1 : 0;
						if (!p0)
						{
							p0 = (p2->value == '\'') ? p2+1 : 0;
							if (!p0)
							{
								p0 = (p2->value == '\"') ? p2+1 : 0;
								if (!p0)
								{
									p0 = (p2->value == '[') ? p2+1 : 0;
									if (!p0)
									{
										p0 = (p2->value == ']') ? p2+1 : 0;
										if (!p0)
										{
											p0 = (p2->value == '\\') ? p2+1 : 0;
											if (!p0)
											{
												p0 = (p2->value >= '1' && p2->value <= '9') ? p2+1 : 0;
												if (p0)
												{
													for (;;)
													{
														Node* p3 = (p0->value >= '0' && p0->value <= '9') ? p0+1 : 0;
														if (!p3)
															break;
														p0 = p3;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (!p0)
			{
				p0 = p1;
				Node* p4 = (p1->value == '\\') ? p1+1 : 0;
				if (p4)
					p0 = 0;
				if (p0)
				{
					p0 = (p0->value != 0) ? p0+1 : 0;
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Class(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Class, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '[') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p1 = Parse_Class_1(p0);
					if (!p1)
						break;
					p0 = p1;
				}
				if (p0)
				{
					p0 = (p0->value == ']') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Class_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Class_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == ']') ? p0+1 : 0;
			if (p1)
				p0 = 0;
			if (p0)
			{
				p0 = Parse_Range(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Comment(Node* p0)
		{
			p0 = (p0->value == '#') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p1 = p0;
					Node* p2 = Parse_EndOfLine(p0);
					if (p2)
						p1 = 0;
					if (p1)
					{
						p1 = (p1->value != 0) ? p1+1 : 0;
					}
					if (!p1)
						break;
					p0 = p1;
				}
				if (p0)
				{
					p0 = Parse_EndOfLine(p0);
				}
			}
			return p0;
		}

		static Node* Parse_DOT(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_DOT, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '.') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Definition(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Definition, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Identifier(p0);
			if (p0)
			{
				p0 = Parse_Spacing(p0);
				if (p0)
				{
					p0 = Parse_LEFTARROW(p0);
					if (p0)
					{
						p0 = Parse_Expression(p0);
					}
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_EndOfFile(Node* p0)
		{
			Node* p1 = (p0->value != 0) ? p0+1 : 0;
			if (p1)
				p0 = 0;
			return p0;
		}

		static Node* Parse_EndOfLine(Node* p0)
		{
			Node* p1 = p0;
			p0 = (p1->value == '\r') ? p1+1 : 0;
			if (p0)
			{
				p0 = (p0->value == '\n') ? p0+1 : 0;
			}
			if (!p0)
			{
				p0 = (p1->value == '\n') ? p1+1 : 0;
				if (!p0)
				{
					p0 = (p1->value == '\r') ? p1+1 : 0;
				}
			}
			return p0;
		}

		static Node* Parse_Expression(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Expression, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Sequence(p0);
			if (p0)
			{
				for (;;)
				{
					Node* p1 = Parse_Expression_1(p0);
					if (!p1)
						break;
					p0 = p1;
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Expression_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Expression_1, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_SLASH(p0);
			if (p0)
			{
				p0 = Parse_Sequence(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Grammar(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Grammar, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Spacing(p0);
			if (p0)
			{
				p0 = Parse_Definition(p0);
				if (p0)
				{
					for (;;)
					{
						Node* p1 = Parse_Definition(p0);
						if (!p1)
							break;
						p0 = p1;
					}
					if (p0)
					{
						p0 = Parse_EndOfFile(p0);
					}
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Identifier(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Identifier, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = (p1->value >= 'a' && p1->value <= 'z') ? p1+1 : 0;
			if (!p0)
			{
				p0 = (p1->value >= 'A' && p1->value <= 'Z') ? p1+1 : 0;
				if (!p0)
				{
					p0 = (p1->value == '_') ? p1+1 : 0;
				}
			}
			if (p0)
			{
				for (;;)
				{
					Node* p2 = (p0->value >= 'a' && p0->value <= 'z') ? p0+1 : 0;
					if (!p2)
					{
						p2 = (p0->value >= 'A' && p0->value <= 'Z') ? p0+1 : 0;
						if (!p2)
						{
							p2 = (p0->value >= '0' && p0->value <= '9') ? p0+1 : 0;
							if (!p2)
							{
								p2 = (p0->value == '_') ? p0+1 : 0;
							}
						}
					}
					if (!p2)
						break;
					p0 = p2;
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_LEFTARROW(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_LEFTARROW, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '<') ? p0+1 : 0;
			if (p0)
			{
				Node* p1 = p0;
				p0 = (p1->value == '-') ? p1+1 : 0;
				if (!p0)
				{
					p0 = (p1->value == '=') ? p1+1 : 0;
					if (!p0)
					{
						p0 = (p1->value == '<') ? p1+1 : 0;
					}
				}
				if (p0)
				{
					p0 = Parse_Spacing(p0);
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Literal(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_Literal_1(p1);
			if (!p0)
			{
				p0 = Parse_Literal_2(p1);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Literal_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_1, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '\'') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p1 = Parse_Literal_1_1(p0);
					if (!p1)
						break;
					p0 = p1;
				}
				if (p0)
				{
					p0 = (p0->value == '\'') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Literal_1_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_1_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\'') ? p0+1 : 0;
			if (p1)
				p0 = 0;
			if (p0)
			{
				p0 = Parse_Char(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Literal_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_2, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '\"') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p1 = Parse_Literal_2_1(p0);
					if (!p1)
						break;
					p0 = p1;
				}
				if (p0)
				{
					p0 = (p0->value == '\"') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Literal_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Literal_2_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = (p0->value == '\"') ? p0+1 : 0;
			if (p1)
				p0 = 0;
			if (p0)
			{
				p0 = Parse_Char(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_NOT(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_NOT, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '!') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_OPEN(Node* p0)
		{
			p0 = (p0->value == '(') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p0;
		}

		static Node* Parse_PLUS(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_PLUS, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '+') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Prefix(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Prefix, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_AND(p1);
			if (!p0)
			{
				p0 = Parse_NOT(p1);
				if (!p0)
				{
					p0 = p1;
				}
			}
			if (p0)
			{
				p0 = Parse_Suffix(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_Primary_1(p1);
			if (!p0)
			{
				p0 = Parse_Primary_2(p1);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_1, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Identifier(p0);
			if (p0)
			{
				p0 = Parse_Spacing(p0);
				if (p0)
				{
					Node* p1 = Parse_LEFTARROW(p0);
					if (p1)
						p0 = 0;
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_Primary_2_1(p1);
			if (!p0)
			{
				p0 = Parse_Primary_2_2(p1);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_1, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_OPEN(p0);
			if (p0)
			{
				p0 = Parse_Expression(p0);
				if (p0)
				{
					p0 = Parse_CLOSE(p0);
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary_2_2(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_2, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_Literal(p1);
			if (!p0)
			{
				p0 = Parse_Primary_2_2_1(p1);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Primary_2_2_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Primary_2_2_1, 0));
			if (!r.second)
				return r.first->second;
			Node* p1 = p0;
			p0 = Parse_Class(p1);
			if (!p0)
			{
				p0 = Parse_DOT(p1);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_QUESTION(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_QUESTION, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '?') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Range(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Range, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Char(p0);
			if (p0)
			{
				Node* p1 = p0;
				p0 = Parse_Range_1(p1);
				if (!p0)
				{
					p0 = p1;
				}
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Range_1(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Range_1, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '-') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Char(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_SLASH(Node* p0)
		{
			p0 = (p0->value == '/') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p0;
		}

		static Node* Parse_STAR(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_STAR, 0));
			if (!r.second)
				return r.first->second;
			p0 = (p0->value == '*') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Sequence(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Sequence, 0));
			if (!r.second)
				return r.first->second;
			for (;;)
			{
				Node* p1 = Parse_Prefix(p0);
				if (!p1)
					break;
				p0 = p1;
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Space(Node* p0)
		{
			Node* p1 = p0;
			p0 = (p1->value == ' ') ? p1+1 : 0;
			if (!p0)
			{
				p0 = (p1->value == '\t') ? p1+1 : 0;
				if (!p0)
				{
					p0 = Parse_EndOfLine(p1);
				}
			}
			return p0;
		}

		static Node* Parse_Spacing(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Spacing, 0));
			if (!r.second)
				return r.first->second;
			for (;;)
			{
				Node* p1 = Parse_Space(p0);
				if (!p1)
				{
					p1 = Parse_Comment(p0);
				}
				if (!p1)
					break;
				p0 = p1;
			}
			r.first->second = p0;
			return p0;
		}

		static Node* Parse_Suffix(Node* p0)
		{
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_Suffix, 0));
			if (!r.second)
				return r.first->second;
			p0 = Parse_Primary(p0);
			if (p0)
			{
				Node* p1 = p0;
				p0 = Parse_QUESTION(p1);
				if (!p0)
				{
					p0 = Parse_STAR(p1);
					if (!p0)
					{
						p0 = Parse_PLUS(p1);
						if (!p0)
						{
							p0 = p1;
						}
					}
				}
			}
			r.first->second = p0;
			return p0;
		}
		
		static Node* Traverse_AND(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_AND(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '&') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_CLOSE(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_CLOSE(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == ')') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_Char(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Char(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = (p2->value == '\\') ? p2+1 : 0;
			if (p0)
			{
				Node* p3 = p0;
				p0 = (p3->value == 'n') ? p3+1 : 0;
				if (!p0)
				{
					p0 = (p3->value == 'r') ? p3+1 : 0;
					if (!p0)
					{
						p0 = (p3->value == 't') ? p3+1 : 0;
						if (!p0)
						{
							p0 = (p3->value == '\'') ? p3+1 : 0;
							if (!p0)
							{
								p0 = (p3->value == '\"') ? p3+1 : 0;
								if (!p0)
								{
									p0 = (p3->value == '[') ? p3+1 : 0;
									if (!p0)
									{
										p0 = (p3->value == ']') ? p3+1 : 0;
										if (!p0)
										{
											p0 = (p3->value == '\\') ? p3+1 : 0;
											if (!p0)
											{
												p0 = (p3->value >= '1' && p3->value <= '9') ? p3+1 : 0;
												if (p0)
												{
													for (;;)
													{
														Node* p4 = (p0->value >= '0' && p0->value <= '9') ? p0+1 : 0;
														if (!p4)
															break;
														p0 = p4;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (!p0)
			{
				p0 = p2;
				Node* p5 = (p2->value == '\\') ? p2+1 : 0;
				if (p5)
					p0 = 0;
				if (p0)
				{
					p0 = (p0->value != 0) ? p0+1 : 0;
				}
			}
			return p1;
		}

		static Node* Traverse_Class(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Class(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '[') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p2 = Traverse_Class_1(p0, v);
					if (!p2)
						break;
					p0 = p2;
				}
				if (p0)
				{
					p0 = (p0->value == ']') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Class_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Class_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == ']') ? p0+1 : 0;
			if (p2)
				p0 = 0;
			if (p0)
			{
				Node* p3 = p0;
				p0 = p3->end.find(PTNodeType_Range)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Range, p3));
			}
			return p1;
		}

		static Node* Traverse_Comment(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Comment(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '#') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p2 = p0;
					Node* p3 = Parse_EndOfLine(p0);
					if (p3)
						p2 = 0;
					if (p2)
					{
						p2 = (p2->value != 0) ? p2+1 : 0;
					}
					if (!p2)
						break;
					p0 = p2;
				}
				if (p0)
				{
					p0 = Parse_EndOfLine(p0);
				}
			}
			return p1;
		}

		static Node* Traverse_DOT(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_DOT(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '.') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_Definition(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Definition(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Identifier)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Identifier, p2));
			if (p0)
			{
				p0 = Parse_Spacing(p0);
				if (p0)
				{
					Node* p3 = p0;
					p0 = p3->end.find(PTNodeType_LEFTARROW)->second;
					if (p0)
						v.push_back(PTNodeChild(PTNodeType_LEFTARROW, p3));
					if (p0)
					{
						Node* p4 = p0;
						p0 = p4->end.find(PTNodeType_Expression)->second;
						if (p0)
							v.push_back(PTNodeChild(PTNodeType_Expression, p4));
					}
				}
			}
			return p1;
		}

		static Node* Traverse_EndOfFile(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_EndOfFile(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value != 0) ? p0+1 : 0;
			if (p2)
				p0 = 0;
			return p1;
		}

		static Node* Traverse_EndOfLine(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_EndOfLine(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = (p2->value == '\r') ? p2+1 : 0;
			if (p0)
			{
				p0 = (p0->value == '\n') ? p0+1 : 0;
			}
			if (!p0)
			{
				p0 = (p2->value == '\n') ? p2+1 : 0;
				if (!p0)
				{
					p0 = (p2->value == '\r') ? p2+1 : 0;
				}
			}
			return p1;
		}

		static Node* Traverse_Expression(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Expression(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Sequence)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Sequence, p2));
			if (p0)
			{
				for (;;)
				{
					Node* p3 = Traverse_Expression_1(p0, v);
					if (!p3)
						break;
					p0 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_Expression_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Expression_1(p0);
			if (!p1)
				return 0;
			p0 = Parse_SLASH(p0);
			if (p0)
			{
				Node* p2 = p0;
				p0 = p2->end.find(PTNodeType_Sequence)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Sequence, p2));
			}
			return p1;
		}

		static Node* Traverse_Grammar(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Grammar(p0);
			if (!p1)
				return 0;
			p0 = Parse_Spacing(p0);
			if (p0)
			{
				Node* p2 = p0;
				p0 = p2->end.find(PTNodeType_Definition)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Definition, p2));
				if (p0)
				{
					for (;;)
					{
						Node* p3 = p0->end.find(PTNodeType_Definition)->second;
						if (p3)
							v.push_back(PTNodeChild(PTNodeType_Definition, p0));
						if (!p3)
							break;
						p0 = p3;
					}
					if (p0)
					{
						p0 = Parse_EndOfFile(p0);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Identifier(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Identifier(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = (p2->value >= 'a' && p2->value <= 'z') ? p2+1 : 0;
			if (!p0)
			{
				p0 = (p2->value >= 'A' && p2->value <= 'Z') ? p2+1 : 0;
				if (!p0)
				{
					p0 = (p2->value == '_') ? p2+1 : 0;
				}
			}
			if (p0)
			{
				for (;;)
				{
					Node* p3 = (p0->value >= 'a' && p0->value <= 'z') ? p0+1 : 0;
					if (!p3)
					{
						p3 = (p0->value >= 'A' && p0->value <= 'Z') ? p0+1 : 0;
						if (!p3)
						{
							p3 = (p0->value >= '0' && p0->value <= '9') ? p0+1 : 0;
							if (!p3)
							{
								p3 = (p0->value == '_') ? p0+1 : 0;
							}
						}
					}
					if (!p3)
						break;
					p0 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_LEFTARROW(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_LEFTARROW(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '<') ? p0+1 : 0;
			if (p0)
			{
				Node* p2 = p0;
				p0 = (p2->value == '-') ? p2+1 : 0;
				if (!p0)
				{
					p0 = (p2->value == '=') ? p2+1 : 0;
					if (!p0)
					{
						p0 = (p2->value == '<') ? p2+1 : 0;
					}
				}
				if (p0)
				{
					p0 = Parse_Spacing(p0);
				}
			}
			return p1;
		}

		static Node* Traverse_Literal(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = Traverse_Literal_1(p2, v);
			if (!p0)
			{
				p0 = Traverse_Literal_2(p2, v);
			}
			return p1;
		}

		static Node* Traverse_Literal_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_1(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '\'') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p2 = Traverse_Literal_1_1(p0, v);
					if (!p2)
						break;
					p0 = p2;
				}
				if (p0)
				{
					p0 = (p0->value == '\'') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Literal_1_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_1_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\'') ? p0+1 : 0;
			if (p2)
				p0 = 0;
			if (p0)
			{
				Node* p3 = p0;
				p0 = p3->end.find(PTNodeType_Char)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Char, p3));
			}
			return p1;
		}

		static Node* Traverse_Literal_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_2(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '\"') ? p0+1 : 0;
			if (p0)
			{
				for (;;)
				{
					Node* p2 = Traverse_Literal_2_1(p0, v);
					if (!p2)
						break;
					p0 = p2;
				}
				if (p0)
				{
					p0 = (p0->value == '\"') ? p0+1 : 0;
					if (p0)
					{
						p0 = Parse_Spacing(p0);
					}
				}
			}
			return p1;
		}

		static Node* Traverse_Literal_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Literal_2_1(p0);
			if (!p1)
				return 0;
			Node* p2 = (p0->value == '\"') ? p0+1 : 0;
			if (p2)
				p0 = 0;
			if (p0)
			{
				Node* p3 = p0;
				p0 = p3->end.find(PTNodeType_Char)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Char, p3));
			}
			return p1;
		}

		static Node* Traverse_NOT(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_NOT(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '!') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_OPEN(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_OPEN(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '(') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_PLUS(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_PLUS(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '+') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_Prefix(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Prefix(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = Parse_AND(p2);
			if (!p0)
			{
				p0 = Parse_NOT(p2);
				if (!p0)
				{
					p0 = p2;
				}
			}
			if (p0)
			{
				Node* p3 = p0;
				p0 = p3->end.find(PTNodeType_Suffix)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Suffix, p3));
			}
			return p1;
		}

		static Node* Traverse_Primary(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = Traverse_Primary_1(p2, v);
			if (!p0)
			{
				p0 = Traverse_Primary_2(p2, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_1(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Identifier)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Identifier, p2));
			if (p0)
			{
				p0 = Parse_Spacing(p0);
				if (p0)
				{
					Node* p3 = p0->end.find(PTNodeType_LEFTARROW)->second;
					if (p3)
						v.push_back(PTNodeChild(PTNodeType_LEFTARROW, p0));
					if (p3)
						p0 = 0;
				}
			}
			return p1;
		}

		static Node* Traverse_Primary_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = Traverse_Primary_2_1(p2, v);
			if (!p0)
			{
				p0 = Traverse_Primary_2_2(p2, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_1(p0);
			if (!p1)
				return 0;
			p0 = Parse_OPEN(p0);
			if (p0)
			{
				Node* p2 = p0;
				p0 = p2->end.find(PTNodeType_Expression)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Expression, p2));
				if (p0)
				{
					p0 = Parse_CLOSE(p0);
				}
			}
			return p1;
		}

		static Node* Traverse_Primary_2_2(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_2(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Literal)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Literal, p2));
			if (!p0)
			{
				p0 = Traverse_Primary_2_2_1(p2, v);
			}
			return p1;
		}

		static Node* Traverse_Primary_2_2_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Primary_2_2_1(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Class)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Class, p2));
			if (!p0)
			{
				p0 = Parse_DOT(p2);
			}
			return p1;
		}

		static Node* Traverse_QUESTION(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_QUESTION(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '?') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_Range(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Range(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Char)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Char, p2));
			if (p0)
			{
				Node* p3 = p0;
				p0 = Traverse_Range_1(p3, v);
				if (!p0)
				{
					p0 = p3;
				}
			}
			return p1;
		}

		static Node* Traverse_Range_1(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Range_1(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '-') ? p0+1 : 0;
			if (p0)
			{
				Node* p2 = p0;
				p0 = p2->end.find(PTNodeType_Char)->second;
				if (p0)
					v.push_back(PTNodeChild(PTNodeType_Char, p2));
			}
			return p1;
		}

		static Node* Traverse_SLASH(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_SLASH(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '/') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_STAR(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_STAR(p0);
			if (!p1)
				return 0;
			p0 = (p0->value == '*') ? p0+1 : 0;
			if (p0)
			{
				p0 = Parse_Spacing(p0);
			}
			return p1;
		}

		static Node* Traverse_Sequence(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Sequence(p0);
			if (!p1)
				return 0;
			for (;;)
			{
				Node* p2 = p0->end.find(PTNodeType_Prefix)->second;
				if (p2)
					v.push_back(PTNodeChild(PTNodeType_Prefix, p0));
				if (!p2)
					break;
				p0 = p2;
			}
			return p1;
		}

		static Node* Traverse_Space(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Space(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = (p2->value == ' ') ? p2+1 : 0;
			if (!p0)
			{
				p0 = (p2->value == '\t') ? p2+1 : 0;
				if (!p0)
				{
					p0 = Parse_EndOfLine(p2);
				}
			}
			return p1;
		}

		static Node* Traverse_Spacing(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Spacing(p0);
			if (!p1)
				return 0;
			for (;;)
			{
				Node* p2 = Parse_Space(p0);
				if (!p2)
				{
					p2 = Parse_Comment(p0);
				}
				if (!p2)
					break;
				p0 = p2;
			}
			return p1;
		}

		static Node* Traverse_Suffix(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_Suffix(p0);
			if (!p1)
				return 0;
			Node* p2 = p0;
			p0 = p2->end.find(PTNodeType_Primary)->second;
			if (p0)
				v.push_back(PTNodeChild(PTNodeType_Primary, p2));
			if (p0)
			{
				Node* p3 = p0;
				p0 = Parse_QUESTION(p3);
				if (!p0)
				{
					p0 = Parse_STAR(p3);
					if (!p0)
					{
						p0 = Parse_PLUS(p3);
						if (!p0)
						{
							p0 = p3;
						}
					}
				}
			}
			return p1;
		}
	};
}

namespace PEGParser
{
	Node* Parse(PTNodeType _type, Node* _symbol)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Private::Parse_AND(_symbol);
			case PTNodeType_CLOSE: return Private::Parse_CLOSE(_symbol);
			case PTNodeType_Char: return Private::Parse_Char(_symbol);
			case PTNodeType_Class: return Private::Parse_Class(_symbol);
			case PTNodeType_Class_1: return Private::Parse_Class_1(_symbol);
			case PTNodeType_Comment: return Private::Parse_Comment(_symbol);
			case PTNodeType_DOT: return Private::Parse_DOT(_symbol);
			case PTNodeType_Definition: return Private::Parse_Definition(_symbol);
			case PTNodeType_EndOfFile: return Private::Parse_EndOfFile(_symbol);
			case PTNodeType_EndOfLine: return Private::Parse_EndOfLine(_symbol);
			case PTNodeType_Expression: return Private::Parse_Expression(_symbol);
			case PTNodeType_Expression_1: return Private::Parse_Expression_1(_symbol);
			case PTNodeType_Grammar: return Private::Parse_Grammar(_symbol);
			case PTNodeType_Identifier: return Private::Parse_Identifier(_symbol);
			case PTNodeType_LEFTARROW: return Private::Parse_LEFTARROW(_symbol);
			case PTNodeType_Literal: return Private::Parse_Literal(_symbol);
			case PTNodeType_Literal_1: return Private::Parse_Literal_1(_symbol);
			case PTNodeType_Literal_1_1: return Private::Parse_Literal_1_1(_symbol);
			case PTNodeType_Literal_2: return Private::Parse_Literal_2(_symbol);
			case PTNodeType_Literal_2_1: return Private::Parse_Literal_2_1(_symbol);
			case PTNodeType_NOT: return Private::Parse_NOT(_symbol);
			case PTNodeType_OPEN: return Private::Parse_OPEN(_symbol);
			case PTNodeType_PLUS: return Private::Parse_PLUS(_symbol);
			case PTNodeType_Prefix: return Private::Parse_Prefix(_symbol);
			case PTNodeType_Primary: return Private::Parse_Primary(_symbol);
			case PTNodeType_Primary_1: return Private::Parse_Primary_1(_symbol);
			case PTNodeType_Primary_2: return Private::Parse_Primary_2(_symbol);
			case PTNodeType_Primary_2_1: return Private::Parse_Primary_2_1(_symbol);
			case PTNodeType_Primary_2_2: return Private::Parse_Primary_2_2(_symbol);
			case PTNodeType_Primary_2_2_1: return Private::Parse_Primary_2_2_1(_symbol);
			case PTNodeType_QUESTION: return Private::Parse_QUESTION(_symbol);
			case PTNodeType_Range: return Private::Parse_Range(_symbol);
			case PTNodeType_Range_1: return Private::Parse_Range_1(_symbol);
			case PTNodeType_SLASH: return Private::Parse_SLASH(_symbol);
			case PTNodeType_STAR: return Private::Parse_STAR(_symbol);
			case PTNodeType_Sequence: return Private::Parse_Sequence(_symbol);
			case PTNodeType_Space: return Private::Parse_Space(_symbol);
			case PTNodeType_Spacing: return Private::Parse_Spacing(_symbol);
			case PTNodeType_Suffix: return Private::Parse_Suffix(_symbol);
		}
		return 0;
	}

	Node* Traverse(PTNodeType _type, Node* _symbol, PTNodeChildren& _children)
	{
		switch (_type)
		{
			case PTNodeType_AND: return Private::Traverse_AND(_symbol, _children);
			case PTNodeType_CLOSE: return Private::Traverse_CLOSE(_symbol, _children);
			case PTNodeType_Char: return Private::Traverse_Char(_symbol, _children);
			case PTNodeType_Class: return Private::Traverse_Class(_symbol, _children);
			case PTNodeType_Class_1: return Private::Traverse_Class_1(_symbol, _children);
			case PTNodeType_Comment: return Private::Traverse_Comment(_symbol, _children);
			case PTNodeType_DOT: return Private::Traverse_DOT(_symbol, _children);
			case PTNodeType_Definition: return Private::Traverse_Definition(_symbol, _children);
			case PTNodeType_EndOfFile: return Private::Traverse_EndOfFile(_symbol, _children);
			case PTNodeType_EndOfLine: return Private::Traverse_EndOfLine(_symbol, _children);
			case PTNodeType_Expression: return Private::Traverse_Expression(_symbol, _children);
			case PTNodeType_Expression_1: return Private::Traverse_Expression_1(_symbol, _children);
			case PTNodeType_Grammar: return Private::Traverse_Grammar(_symbol, _children);
			case PTNodeType_Identifier: return Private::Traverse_Identifier(_symbol, _children);
			case PTNodeType_LEFTARROW: return Private::Traverse_LEFTARROW(_symbol, _children);
			case PTNodeType_Literal: return Private::Traverse_Literal(_symbol, _children);
			case PTNodeType_Literal_1: return Private::Traverse_Literal_1(_symbol, _children);
			case PTNodeType_Literal_1_1: return Private::Traverse_Literal_1_1(_symbol, _children);
			case PTNodeType_Literal_2: return Private::Traverse_Literal_2(_symbol, _children);
			case PTNodeType_Literal_2_1: return Private::Traverse_Literal_2_1(_symbol, _children);
			case PTNodeType_NOT: return Private::Traverse_NOT(_symbol, _children);
			case PTNodeType_OPEN: return Private::Traverse_OPEN(_symbol, _children);
			case PTNodeType_PLUS: return Private::Traverse_PLUS(_symbol, _children);
			case PTNodeType_Prefix: return Private::Traverse_Prefix(_symbol, _children);
			case PTNodeType_Primary: return Private::Traverse_Primary(_symbol, _children);
			case PTNodeType_Primary_1: return Private::Traverse_Primary_1(_symbol, _children);
			case PTNodeType_Primary_2: return Private::Traverse_Primary_2(_symbol, _children);
			case PTNodeType_Primary_2_1: return Private::Traverse_Primary_2_1(_symbol, _children);
			case PTNodeType_Primary_2_2: return Private::Traverse_Primary_2_2(_symbol, _children);
			case PTNodeType_Primary_2_2_1: return Private::Traverse_Primary_2_2_1(_symbol, _children);
			case PTNodeType_QUESTION: return Private::Traverse_QUESTION(_symbol, _children);
			case PTNodeType_Range: return Private::Traverse_Range(_symbol, _children);
			case PTNodeType_Range_1: return Private::Traverse_Range_1(_symbol, _children);
			case PTNodeType_SLASH: return Private::Traverse_SLASH(_symbol, _children);
			case PTNodeType_STAR: return Private::Traverse_STAR(_symbol, _children);
			case PTNodeType_Sequence: return Private::Traverse_Sequence(_symbol, _children);
			case PTNodeType_Space: return Private::Traverse_Space(_symbol, _children);
			case PTNodeType_Spacing: return Private::Traverse_Spacing(_symbol, _children);
			case PTNodeType_Suffix: return Private::Traverse_Suffix(_symbol, _children);
		}
		return 0;
	}
	void Print(std::ostream& _os, PTNodeType _type, Node* _pNode, int _tabs, int _maxLineSize)
	{
		Node* pEnd = Parse(_type, _pNode);
		if (!pEnd)
			return;
		int tabCount = _tabs;
		while (tabCount--)
		  _os << "    ";
		switch (_type)
		{
			case PTNodeType_AND: _os << "AND"; break;
			case PTNodeType_CLOSE: _os << "CLOSE"; break;
			case PTNodeType_Char: _os << "Char"; break;
			case PTNodeType_Class: _os << "Class"; break;
			case PTNodeType_Class_1: _os << "Class_1"; break;
			case PTNodeType_Comment: _os << "Comment"; break;
			case PTNodeType_DOT: _os << "DOT"; break;
			case PTNodeType_Definition: _os << "Definition"; break;
			case PTNodeType_EndOfFile: _os << "EndOfFile"; break;
			case PTNodeType_EndOfLine: _os << "EndOfLine"; break;
			case PTNodeType_Expression: _os << "Expression"; break;
			case PTNodeType_Expression_1: _os << "Expression_1"; break;
			case PTNodeType_Grammar: _os << "Grammar"; break;
			case PTNodeType_Identifier: _os << "Identifier"; break;
			case PTNodeType_LEFTARROW: _os << "LEFTARROW"; break;
			case PTNodeType_Literal: _os << "Literal"; break;
			case PTNodeType_Literal_1: _os << "Literal_1"; break;
			case PTNodeType_Literal_1_1: _os << "Literal_1_1"; break;
			case PTNodeType_Literal_2: _os << "Literal_2"; break;
			case PTNodeType_Literal_2_1: _os << "Literal_2_1"; break;
			case PTNodeType_NOT: _os << "NOT"; break;
			case PTNodeType_OPEN: _os << "OPEN"; break;
			case PTNodeType_PLUS: _os << "PLUS"; break;
			case PTNodeType_Prefix: _os << "Prefix"; break;
			case PTNodeType_Primary: _os << "Primary"; break;
			case PTNodeType_Primary_1: _os << "Primary_1"; break;
			case PTNodeType_Primary_2: _os << "Primary_2"; break;
			case PTNodeType_Primary_2_1: _os << "Primary_2_1"; break;
			case PTNodeType_Primary_2_2: _os << "Primary_2_2"; break;
			case PTNodeType_Primary_2_2_1: _os << "Primary_2_2_1"; break;
			case PTNodeType_QUESTION: _os << "QUESTION"; break;
			case PTNodeType_Range: _os << "Range"; break;
			case PTNodeType_Range_1: _os << "Range_1"; break;
			case PTNodeType_SLASH: _os << "SLASH"; break;
			case PTNodeType_STAR: _os << "STAR"; break;
			case PTNodeType_Sequence: _os << "Sequence"; break;
			case PTNodeType_Space: _os << "Space"; break;
			case PTNodeType_Spacing: _os << "Spacing"; break;
			case PTNodeType_Suffix: _os << "Suffix"; break;
		}
		_os << ": \"";
		size_t lineSize = 0;
		for (Node* p = _pNode; p != pEnd; ++p)
		{
			_os << EscapeChar(p->value);
			if (++lineSize >= _maxLineSize)
			{
				_os << "...";
				break;
			}
		}
		_os << "\"\n";
		PTNodeChildren children;
		Traverse(_type, _pNode, children);
		for (PTNodeChildren::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
		{
			Print(_os, i->first, i->second, _tabs + 1, _maxLineSize);
		}
	}
}
