// This file was automatically generated by IPG on Fri Aug 26 09:09:31 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#ifndef BOOTSTRAP_TEST
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <boost/format.hpp>
#endif

#ifndef BOOTSTRAP_TEST
#include <vector>
#include <bitset>
#include <boost/shared_ptr.hpp>
#include <tr1/unordered_map>
#include <tr1/unordered_set>
#endif

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_CLASS,
		SymbolType_CLASS_1,
		SymbolType_Char,
		SymbolType_Definition,
		SymbolType_Expression,
		SymbolType_Expression_1,
		SymbolType_Grammar,
		SymbolType_Grammar_1,
		SymbolType_IDENTIFIER_1,
		SymbolType_Identifier,
		SymbolType_Item,
		SymbolType_Item_1,
		SymbolType_Item_2,
		SymbolType_LEFTARROW,
		SymbolType_LITERAL,
		SymbolType_LITERAL_1,
		SymbolType_Primary,
		SymbolType_Primary_1,
		SymbolType_Primary_2,
		SymbolType_Primary_3,
		SymbolType_Range,
		SymbolType_Sequence,
		SymbolTypeInvalid,
		SymbolTypeCount = SymbolTypeInvalid
	};

	struct Symbol
	{
		SymbolType type;
		size_t length;
		const char* value;
	};
	typedef std::vector<Symbol> Symbols;
	typedef std::tr1::unordered_map<const char*, const char*> EndMap;
	typedef std::tr1::unordered_set<const char*> FailSet;
	

	const char* SymbolName(SymbolType _type);

	class Parser
	{
	public:
		bool Parse(SymbolType _type, const char*& _p);
		bool Traverse(SymbolType _type, const char*& _p, Symbols& _children);
		void Print(std::ostream& _os, SymbolType _type, const char* _pNode, int _tabs = 0, int _maxLineSize = 100);

	private:
		bool Visit(SymbolType _type, const char*& _p, Symbols& _v);
		EndMap end[SymbolTypeCount];
		FailSet fail[SymbolTypeCount];

		bool Parse_CLASS(const char*& p);
		bool Parse_CLASS_1(const char*& p);
		bool Parse_Char(const char*& p);
		bool Parse_Definition(const char*& p);
		bool Parse_Expression(const char*& p);
		bool Parse_Expression_1(const char*& p);
		bool Parse_Grammar(const char*& p);
		bool Parse_Grammar_1(const char*& p);
		bool Parse_IDENTIFIER_1(const char*& p);
		bool Parse_Identifier(const char*& p);
		bool Parse_Item(const char*& p);
		bool Parse_Item_1(const char*& p);
		bool Parse_Item_2(const char*& p);
		bool Parse_LEFTARROW(const char*& p);
		bool Parse_LITERAL(const char*& p);
		bool Parse_LITERAL_1(const char*& p);
		bool Parse_Primary(const char*& p);
		bool Parse_Primary_1(const char*& p);
		bool Parse_Primary_2(const char*& p);
		bool Parse_Primary_3(const char*& p);
		bool Parse_Range(const char*& p);
		bool Parse_Sequence(const char*& p);
	};

	class Iterator
	{
	public:
		Iterator() {}
		Iterator(boost::shared_ptr<Parser> _pParser, SymbolType _type, const char* _p) : mpParser(_pParser)
		{
			Symbols children;
			const char* pEnd = _p;
			if (_pParser->Traverse(_type, pEnd, children))
			{
				Symbol symbol = { _type, pEnd - _p, _p };
				mpSiblings.reset(new Symbols(1, symbol));
				mi = mpSiblings->begin();
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
		}
		Iterator& operator++()
		{
			assert(mpSiblings && mi != mpSiblings->end());
			mpChildren.reset();
			if (++mi == mpSiblings->end())
			{
				mpSiblings.reset();
			}
			else
			{
				Symbols children;
				const char* pEnd = mi->value;
				bool r = mpParser->Traverse(mi->type, pEnd, children);
				assert(r && pEnd == mi->value + mi->length);
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
			return *this;
		}
		const Symbol& operator*() const
		{
			static Symbol invalidSymbol = { SymbolTypeInvalid };
			if (mpSiblings && mi != mpSiblings->end())
				return *mi;
			else
				return invalidSymbol;
		}
		const Symbol* operator->() const
		{
			return &**this;
		}
		Iterator GetChild() const
		{
			return Iterator(mpParser, mpChildren);
		}
		void Print(std::ostream& _os, int _tabs = 0, int _maxLineSize = 100)
		{
			assert(mpSiblings && mi != mpSiblings->end());
			mpParser->Print(_os, mi->type, mi->value, _tabs, _maxLineSize);
		}
	private:
		Iterator(boost::shared_ptr<Parser> _pParser, boost::shared_ptr<Symbols> _pSiblings) : mpParser(_pParser), mpSiblings(_pSiblings)
		{
			if (_pSiblings)
			{
				mi = _pSiblings->begin();
				const char* pEnd = mi->value;
				Symbols children;
				bool r =_pParser->Traverse(mi->type, pEnd, children);
				assert(r && pEnd == mi->value + mi->length);
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
		}
		boost::shared_ptr<Parser> mpParser;
		boost::shared_ptr<Symbols> mpSiblings, mpChildren;
		Symbols::iterator mi;
	};

}

namespace
{
	struct EscapeChar
	{
		EscapeChar(char _c);
		char c;
	};

	EscapeChar::EscapeChar(char _c) : c(_c)
	{
	}

	std::ostream& operator<<(std::ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\n': c = 'n'; break;
			case '\r': c = 'r'; break;
			case '\t': c = 't'; break;

			case '\\':
			case '\'':
			case '\"':
				break;

			default:
				_os.put(c);
				return _os;
		}

		_os.put('\\');
		_os.put(c);
		return _os;
	}
}

const char* PEGParser::SymbolName(PEGParser::SymbolType _type)
{
	switch (_type)
	{
		case SymbolType_CLASS: return "CLASS";
		case SymbolType_CLASS_1: return "CLASS_1";
		case SymbolType_Char: return "Char";
		case SymbolType_Definition: return "Definition";
		case SymbolType_Expression: return "Expression";
		case SymbolType_Expression_1: return "Expression_1";
		case SymbolType_Grammar: return "Grammar";
		case SymbolType_Grammar_1: return "Grammar_1";
		case SymbolType_IDENTIFIER_1: return "IDENTIFIER_1";
		case SymbolType_Identifier: return "Identifier";
		case SymbolType_Item: return "Item";
		case SymbolType_Item_1: return "Item_1";
		case SymbolType_Item_2: return "Item_2";
		case SymbolType_LEFTARROW: return "LEFTARROW";
		case SymbolType_LITERAL: return "LITERAL";
		case SymbolType_LITERAL_1: return "LITERAL_1";
		case SymbolType_Primary: return "Primary";
		case SymbolType_Primary_1: return "Primary_1";
		case SymbolType_Primary_2: return "Primary_2";
		case SymbolType_Primary_3: return "Primary_3";
		case SymbolType_Range: return "Range";
		case SymbolType_Sequence: return "Sequence";
		default: throw std::runtime_error(str(boost::format("Invalid Symbol Type: %1%") % _type));
	}
}

bool PEGParser::Parser::Parse_CLASS(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == '[');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ']');
			r = !r;
			p = b;
			if (r)
			{
				r = Parse(SymbolType_Range, p);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
		if (r)
		{
			r = Parse(SymbolType_CLASS_1, p);
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_CLASS_1(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == ']');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Char(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	c = *p++;
	r = (c == '\\');
	if (r)
	{
		const char* b2 = p;
		c = *p++;
		r = (c == 'n');
		if (!r)
		{
			p = b2;
			c = *p++;
			r = (c == 'r');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == 't');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\'');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\"');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '[');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == ']');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\\');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c >= '1' && c <= '9');
										if (r)
										{
											for (;;)
											{
												const char* b3 = p;
												c = *p++;
												r = (c >= '0' && c <= '9');
												if (!r)
												{
													p = b3;
													break;
												}
											}
											r = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\\');
		r = !r;
		p = b;
		if (r)
		{
			c = *p++;
			r = (c != 0);
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Definition(const char*& p)
{
	bool r = true;
	char c;
	r = Parse(SymbolType_Identifier, p);
	if (r)
	{
		r = Parse(SymbolType_IDENTIFIER_1, p);
	}
	if (r)
	{
		r = Parse(SymbolType_LEFTARROW, p);
		if (r)
		{
			r = Parse(SymbolType_Expression, p);
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Expression(const char*& p)
{
	bool r = true;
	char c;
	r = Parse(SymbolType_Sequence, p);
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			r = Parse(SymbolType_Expression_1, p);
			if (r)
			{
				r = Parse(SymbolType_Sequence, p);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Expression_1(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == '/');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Grammar(const char*& p)
{
	bool r = true;
	char c;
	r = Parse(SymbolType_Grammar_1, p);
	if (r)
	{
		r = Parse(SymbolType_Definition, p);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				r = Parse(SymbolType_Definition, p);
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c != 0);
				r = !r;
				p = b2;
			}
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Grammar_1(const char*& p)
{
	bool r = true;
	char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
	return r;
}

bool PEGParser::Parser::Parse_IDENTIFIER_1(const char*& p)
{
	bool r = true;
	char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
	return r;
}

bool PEGParser::Parser::Parse_Identifier(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	c = *p++;
	r = (c >= 'a' && c <= 'z');
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c >= 'A' && c <= 'Z');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '_');
		}
	}
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c >= '0' && c <= '9');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '_');
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Item(const char*& p)
{
	bool r = true;
	char c;
	r = Parse(SymbolType_Item_1, p);
	if (r)
	{
		r = Parse(SymbolType_Primary, p);
		if (r)
		{
			r = Parse(SymbolType_Item_2, p);
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Item_1(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	c = *p++;
	r = (c == '&');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '!');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Item_2(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	c = *p++;
	r = (c == '?');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '*');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '+');
			if (r)
			{
				for (;;)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b15 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b16 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b16;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											r = true;
										}
									}
								}
								r = !r;
								p = b16;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b16;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b18 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b18;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				r = true;
			}
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_LEFTARROW(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == '<');
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '=');
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
							r = !r;
							p = b4;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b4;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b7 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b7;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_LITERAL(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	c = *p++;
	r = (c == '\'');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == '\'');
			r = !r;
			p = b2;
			if (r)
			{
				r = Parse(SymbolType_Char, p);
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
		if (r)
		{
			c = *p++;
			r = (c == '\'');
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\"');
		if (r)
		{
			for (;;)
			{
				const char* b3 = p;
				c = *p++;
				r = (c == '\"');
				r = !r;
				p = b3;
				if (r)
				{
					r = Parse(SymbolType_Char, p);
				}
				if (!r)
				{
					p = b3;
					break;
				}
			}
			r = true;
			if (r)
			{
				c = *p++;
				r = (c == '\"');
			}
		}
	}
	if (r)
	{
		r = Parse(SymbolType_LITERAL_1, p);
	}
	return r;
}

bool PEGParser::Parser::Parse_LITERAL_1(const char*& p)
{
	bool r = true;
	char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
	return r;
}

bool PEGParser::Parser::Parse_Primary(const char*& p)
{
	bool r = true;
	char c;
	const char* b = p;
	r = Parse(SymbolType_Identifier, p);
	if (r)
	{
		r = Parse(SymbolType_IDENTIFIER_1, p);
	}
	if (r)
	{
		const char* b2 = p;
		r = Parse(SymbolType_LEFTARROW, p);
		r = !r;
		p = b2;
	}
	if (!r)
	{
		p = b;
		r = Parse(SymbolType_Primary_1, p);
		if (r)
		{
			r = Parse(SymbolType_Expression, p);
			if (r)
			{
				r = Parse(SymbolType_Primary_2, p);
			}
		}
		if (!r)
		{
			p = b;
			r = Parse(SymbolType_LITERAL, p);
			if (!r)
			{
				p = b;
				r = Parse(SymbolType_CLASS, p);
				if (!r)
				{
					p = b;
					r = Parse(SymbolType_Primary_3, p);
				}
			}
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Primary_1(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == '(');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Primary_2(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == ')');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Primary_3(const char*& p)
{
	bool r = true;
	char c;
	c = *p++;
	r = (c == '.');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
	return r;
}

bool PEGParser::Parser::Parse_Range(const char*& p)
{
	bool r = true;
	char c;
	r = Parse(SymbolType_Char, p);
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (r)
		{
			r = Parse(SymbolType_Char, p);
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
	return r;
}

bool PEGParser::Parser::Parse_Sequence(const char*& p)
{
	bool r = true;
	char c;
	for (;;)
	{
		const char* b = p;
		r = Parse(SymbolType_Item, p);
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
	return r;
}

bool PEGParser::Parser::Parse(SymbolType _type, const char*& p)
{
	const char* pBegin = p;
	if (fail[_type].count(pBegin))
		return false;
	EndMap::iterator i = end[_type].find(pBegin);
	if (i != end[_type].end())
	{
		p = i->second;
		return true;
	}

	bool r = true;
	switch (_type)
	{
		case SymbolType_CLASS: r = Parse_CLASS(p); break;
		case SymbolType_CLASS_1: r = Parse_CLASS_1(p); break;
		case SymbolType_Char: r = Parse_Char(p); break;
		case SymbolType_Definition: r = Parse_Definition(p); break;
		case SymbolType_Expression: r = Parse_Expression(p); break;
		case SymbolType_Expression_1: r = Parse_Expression_1(p); break;
		case SymbolType_Grammar: r = Parse_Grammar(p); break;
		case SymbolType_Grammar_1: r = Parse_Grammar_1(p); break;
		case SymbolType_IDENTIFIER_1: r = Parse_IDENTIFIER_1(p); break;
		case SymbolType_Identifier: r = Parse_Identifier(p); break;
		case SymbolType_Item: r = Parse_Item(p); break;
		case SymbolType_Item_1: r = Parse_Item_1(p); break;
		case SymbolType_Item_2: r = Parse_Item_2(p); break;
		case SymbolType_LEFTARROW: r = Parse_LEFTARROW(p); break;
		case SymbolType_LITERAL: r = Parse_LITERAL(p); break;
		case SymbolType_LITERAL_1: r = Parse_LITERAL_1(p); break;
		case SymbolType_Primary: r = Parse_Primary(p); break;
		case SymbolType_Primary_1: r = Parse_Primary_1(p); break;
		case SymbolType_Primary_2: r = Parse_Primary_2(p); break;
		case SymbolType_Primary_3: r = Parse_Primary_3(p); break;
		case SymbolType_Range: r = Parse_Range(p); break;
		case SymbolType_Sequence: r = Parse_Sequence(p); break;
		default:
			assert(false);
			return false;
	}

	if (r)
		end[_type][pBegin] = p;
	else
		fail[_type].insert(pBegin);
	return r;
}

bool PEGParser::Parser::Traverse(PEGParser::SymbolType _type, const char*& p, PEGParser::Symbols& v)
{
	const char* pBegin = p;
	bool r = true;
	char c;
	switch (_type)
	{
		case SymbolType_CLASS:
		{
			if (fail[SymbolType_CLASS].count(pBegin))
				return false;
	c = *p++;
	r = (c == '[');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			size_t s = v.size();
			c = *p++;
			r = (c == ']');
			r = !r;
			p = b;
			if (r)
			{
				r = Visit(SymbolType_Range, p, v);
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				break;
			}
		}
		r = true;
		if (r)
		{
			r = Traverse(SymbolType_CLASS_1, p, v);
		}
	}
			if (r)
				end[SymbolType_CLASS][pBegin] = p;
			else
				fail[SymbolType_CLASS].insert(pBegin);
			return r;
		}

		case SymbolType_CLASS_1:
		{
			if (fail[SymbolType_CLASS_1].count(pBegin))
				return false;
	c = *p++;
	r = (c == ']');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_CLASS_1][pBegin] = p;
			else
				fail[SymbolType_CLASS_1].insert(pBegin);
			return r;
		}

		case SymbolType_Char:
		{
			if (fail[SymbolType_Char].count(pBegin))
				return false;
	const char* b = p;
	c = *p++;
	r = (c == '\\');
	if (r)
	{
		const char* b2 = p;
		c = *p++;
		r = (c == 'n');
		if (!r)
		{
			p = b2;
			c = *p++;
			r = (c == 'r');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == 't');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\'');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\"');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '[');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == ']');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\\');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c >= '1' && c <= '9');
										if (r)
										{
											for (;;)
											{
												const char* b3 = p;
												c = *p++;
												r = (c >= '0' && c <= '9');
												if (!r)
												{
													p = b3;
													break;
												}
											}
											r = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\\');
		r = !r;
		p = b;
		if (r)
		{
			c = *p++;
			r = (c != 0);
		}
	}
			if (r)
				end[SymbolType_Char][pBegin] = p;
			else
				fail[SymbolType_Char].insert(pBegin);
			return r;
		}

		case SymbolType_Definition:
		{
			if (fail[SymbolType_Definition].count(pBegin))
				return false;
	r = Visit(SymbolType_Identifier, p, v);
	if (r)
	{
		r = Traverse(SymbolType_IDENTIFIER_1, p, v);
	}
	if (r)
	{
		r = Visit(SymbolType_LEFTARROW, p, v);
		if (r)
		{
			r = Visit(SymbolType_Expression, p, v);
		}
	}
			if (r)
				end[SymbolType_Definition][pBegin] = p;
			else
				fail[SymbolType_Definition].insert(pBegin);
			return r;
		}

		case SymbolType_Expression:
		{
			if (fail[SymbolType_Expression].count(pBegin))
				return false;
	r = Visit(SymbolType_Sequence, p, v);
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			size_t s = v.size();
			r = Traverse(SymbolType_Expression_1, p, v);
			if (r)
			{
				r = Visit(SymbolType_Sequence, p, v);
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Expression][pBegin] = p;
			else
				fail[SymbolType_Expression].insert(pBegin);
			return r;
		}

		case SymbolType_Expression_1:
		{
			if (fail[SymbolType_Expression_1].count(pBegin))
				return false;
	c = *p++;
	r = (c == '/');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Expression_1][pBegin] = p;
			else
				fail[SymbolType_Expression_1].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar:
		{
			if (fail[SymbolType_Grammar].count(pBegin))
				return false;
	r = Traverse(SymbolType_Grammar_1, p, v);
	if (r)
	{
		r = Visit(SymbolType_Definition, p, v);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				size_t s = v.size();
				r = Visit(SymbolType_Definition, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c != 0);
				r = !r;
				p = b2;
			}
		}
	}
			if (r)
				end[SymbolType_Grammar][pBegin] = p;
			else
				fail[SymbolType_Grammar].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar_1:
		{
			if (fail[SymbolType_Grammar_1].count(pBegin))
				return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
			if (r)
				end[SymbolType_Grammar_1][pBegin] = p;
			else
				fail[SymbolType_Grammar_1].insert(pBegin);
			return r;
		}

		case SymbolType_IDENTIFIER_1:
		{
			if (fail[SymbolType_IDENTIFIER_1].count(pBegin))
				return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
			if (r)
				end[SymbolType_IDENTIFIER_1][pBegin] = p;
			else
				fail[SymbolType_IDENTIFIER_1].insert(pBegin);
			return r;
		}

		case SymbolType_Identifier:
		{
			if (fail[SymbolType_Identifier].count(pBegin))
				return false;
	const char* b = p;
	c = *p++;
	r = (c >= 'a' && c <= 'z');
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c >= 'A' && c <= 'Z');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '_');
		}
	}
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c >= '0' && c <= '9');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '_');
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Identifier][pBegin] = p;
			else
				fail[SymbolType_Identifier].insert(pBegin);
			return r;
		}

		case SymbolType_Item:
		{
			if (fail[SymbolType_Item].count(pBegin))
				return false;
	r = Traverse(SymbolType_Item_1, p, v);
	if (r)
	{
		r = Visit(SymbolType_Primary, p, v);
		if (r)
		{
			r = Traverse(SymbolType_Item_2, p, v);
		}
	}
			if (r)
				end[SymbolType_Item][pBegin] = p;
			else
				fail[SymbolType_Item].insert(pBegin);
			return r;
		}

		case SymbolType_Item_1:
		{
			if (fail[SymbolType_Item_1].count(pBegin))
				return false;
	const char* b = p;
	c = *p++;
	r = (c == '&');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '!');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
			if (r)
				end[SymbolType_Item_1][pBegin] = p;
			else
				fail[SymbolType_Item_1].insert(pBegin);
			return r;
		}

		case SymbolType_Item_2:
		{
			if (fail[SymbolType_Item_2].count(pBegin))
				return false;
	const char* b = p;
	c = *p++;
	r = (c == '?');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '*');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '+');
			if (r)
			{
				for (;;)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b15 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b16 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b16;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											r = true;
										}
									}
								}
								r = !r;
								p = b16;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b16;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b18 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b18;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				r = true;
			}
		}
	}
			if (r)
				end[SymbolType_Item_2][pBegin] = p;
			else
				fail[SymbolType_Item_2].insert(pBegin);
			return r;
		}

		case SymbolType_LEFTARROW:
		{
			if (fail[SymbolType_LEFTARROW].count(pBegin))
				return false;
	c = *p++;
	r = (c == '<');
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '=');
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
							r = !r;
							p = b4;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b4;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b7 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b7;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
	}
			if (r)
				end[SymbolType_LEFTARROW][pBegin] = p;
			else
				fail[SymbolType_LEFTARROW].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL:
		{
			if (fail[SymbolType_LITERAL].count(pBegin))
				return false;
	const char* b = p;
	size_t s = v.size();
	c = *p++;
	r = (c == '\'');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			size_t s2 = v.size();
			c = *p++;
			r = (c == '\'');
			r = !r;
			p = b2;
			if (r)
			{
				r = Visit(SymbolType_Char, p, v);
			}
			if (!r)
			{
				p = b2;
				v.erase(v.begin() + s2, v.end());
				break;
			}
		}
		r = true;
		if (r)
		{
			c = *p++;
			r = (c == '\'');
		}
	}
	if (!r)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		c = *p++;
		r = (c == '\"');
		if (r)
		{
			for (;;)
			{
				const char* b3 = p;
				size_t s3 = v.size();
				c = *p++;
				r = (c == '\"');
				r = !r;
				p = b3;
				if (r)
				{
					r = Visit(SymbolType_Char, p, v);
				}
				if (!r)
				{
					p = b3;
					v.erase(v.begin() + s3, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				c = *p++;
				r = (c == '\"');
			}
		}
	}
	if (r)
	{
		r = Traverse(SymbolType_LITERAL_1, p, v);
	}
			if (r)
				end[SymbolType_LITERAL][pBegin] = p;
			else
				fail[SymbolType_LITERAL].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL_1:
		{
			if (fail[SymbolType_LITERAL_1].count(pBegin))
				return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
			if (r)
				end[SymbolType_LITERAL_1][pBegin] = p;
			else
				fail[SymbolType_LITERAL_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary:
		{
			if (fail[SymbolType_Primary].count(pBegin))
				return false;
	const char* b = p;
	size_t s = v.size();
	r = Visit(SymbolType_Identifier, p, v);
	if (r)
	{
		r = Traverse(SymbolType_IDENTIFIER_1, p, v);
	}
	if (r)
	{
		const char* b2 = p;
		r = Parse(SymbolType_LEFTARROW, p);
		r = !r;
		p = b2;
	}
	if (!r)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		r = Traverse(SymbolType_Primary_1, p, v);
		if (r)
		{
			r = Visit(SymbolType_Expression, p, v);
			if (r)
			{
				r = Traverse(SymbolType_Primary_2, p, v);
			}
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			r = Visit(SymbolType_LITERAL, p, v);
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				r = Visit(SymbolType_CLASS, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					r = Traverse(SymbolType_Primary_3, p, v);
				}
			}
		}
	}
			if (r)
				end[SymbolType_Primary][pBegin] = p;
			else
				fail[SymbolType_Primary].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_1:
		{
			if (fail[SymbolType_Primary_1].count(pBegin))
				return false;
	c = *p++;
	r = (c == '(');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Primary_1][pBegin] = p;
			else
				fail[SymbolType_Primary_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_2:
		{
			if (fail[SymbolType_Primary_2].count(pBegin))
				return false;
	c = *p++;
	r = (c == ')');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Primary_2][pBegin] = p;
			else
				fail[SymbolType_Primary_2].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_3:
		{
			if (fail[SymbolType_Primary_3].count(pBegin))
				return false;
	c = *p++;
	r = (c == '.');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
			if (r)
				end[SymbolType_Primary_3][pBegin] = p;
			else
				fail[SymbolType_Primary_3].insert(pBegin);
			return r;
		}

		case SymbolType_Range:
		{
			if (fail[SymbolType_Range].count(pBegin))
				return false;
	r = Visit(SymbolType_Char, p, v);
	if (r)
	{
		const char* b = p;
		size_t s = v.size();
		c = *p++;
		r = (c == '-');
		if (r)
		{
			r = Visit(SymbolType_Char, p, v);
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			r = true;
		}
	}
			if (r)
				end[SymbolType_Range][pBegin] = p;
			else
				fail[SymbolType_Range].insert(pBegin);
			return r;
		}

		case SymbolType_Sequence:
		{
			if (fail[SymbolType_Sequence].count(pBegin))
				return false;
	for (;;)
	{
		const char* b = p;
		size_t s = v.size();
		r = Visit(SymbolType_Item, p, v);
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			break;
		}
	}
	r = true;
			if (r)
				end[SymbolType_Sequence][pBegin] = p;
			else
				fail[SymbolType_Sequence].insert(pBegin);
			return r;
		}

		default:
			assert(false);
			return false;
	}
}

void PEGParser::Parser::Print(std::ostream& _os, PEGParser::SymbolType _type, const char* _pNode, int _tabs, int _maxLineSize)
{
	Symbols children;
	const char* pEnd = _pNode;
	Traverse(_type, pEnd, children);
	//std::cout << children.size() << "\n";
	if (!pEnd)
		throw std::runtime_error(str(boost::format("Parsing Failed for \"%1%\"") % SymbolName(_type)));

	int tabCount = _tabs;
	while (tabCount--)
		_os << "    ";

	_os << SymbolName(_type) << ": \"";

	size_t lineSize = 0;
	for (const char* p = _pNode; p != pEnd; ++p)
	{
		_os << EscapeChar(*p);
		if (++lineSize >= _maxLineSize)
		{
			_os << "...";
			break;
		}
	}

	_os << "\"\n";

	for (Symbols::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
		Print(_os, i->type, i->value, _tabs + 1, _maxLineSize);
//*
	if (_tabs == 0)
	{
		_os << "Memo Count:\n";
		for (size_t k = 0; k < SymbolTypeCount; ++k)
			_os << boost::format("%1% %|20t|End: %2% %|40t|Fail: %3%\n") % SymbolName(SymbolType(k)) % end[k].size() % fail[k].size();
	}
//*/
}

bool PEGParser::Parser::Visit(PEGParser::SymbolType _type, const char*& _p, PEGParser::Symbols& _v)
{
	const char* pBegin = _p;
	bool r = Parse(_type, _p);
	if (r)
	{
		Symbol symbol = { _type, _p - pBegin, pBegin };
		_v.push_back(symbol);
	}
	return r;
}

