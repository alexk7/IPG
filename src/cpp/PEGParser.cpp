// This file was automatically generated by IPG on Mon Jul 18 19:08:44 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <vector>
#include <map>

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_AND = 1,
		SymbolType_CLOSE = 2,
		SymbolType_Char = 3,
		SymbolType_Class = 4,
		SymbolType_Comment = 5,
		SymbolType_DOT = 6,
		SymbolType_Definition = 7,
		SymbolType_EndOfFile = 8,
		SymbolType_EndOfLine = 9,
		SymbolType_Expression = 10,
		SymbolType_Grammar = 11,
		SymbolType_Identifier = 12,
		SymbolType_LEFTARROW = 13,
		SymbolType_Literal = 14,
		SymbolType_NOT = 15,
		SymbolType_OPEN = 16,
		SymbolType_PLUS = 17,
		SymbolType_Prefix = 18,
		SymbolType_Primary = 19,
		SymbolType_QUESTION = 20,
		SymbolType_Range = 21,
		SymbolType_SLASH = 22,
		SymbolType_STAR = 23,
		SymbolType_Sequence = 24,
		SymbolType_Space = 25,
		SymbolType_Spacing = 26,
		SymbolType_Suffix = 27,
	};

	struct Node;
	typedef std::map<SymbolType, Node*> SymbolTypeToPtr;

	struct Node
	{
		char value;
		SymbolTypeToPtr end;
	};

	typedef std::pair<SymbolType, Node*> PTNodeChild;
	typedef std::vector<PTNodeChild> PTNodeChildren;

	Node* Parse(SymbolType _type, Node* _symbol);
	Node* Traverse(SymbolType _type, Node* _symbol, PTNodeChildren& _children);
	const char* SymbolName(SymbolType _type);
	void Print(std::ostream& _os, SymbolType _type, Node* _pNode, int _tabs = 0, int _maxLineSize = 100);
}

using namespace PEGParser;

namespace
{
	typedef SymbolTypeToPtr::value_type Memo;
	typedef SymbolTypeToPtr::iterator MemoIterator;
	typedef std::pair<SymbolTypeToPtr::iterator, bool> MemoInsertResult;

	struct EscapeChar
	{
		EscapeChar(char _c) : c(_c) {}
		char c;
	};

	std::ostream& operator<<(std::ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\\': c = '\\'; break;
			case '\n': c = 'n';  break;
			case '\r': c = 'r';  break;
			case '\t': c = 't';  break;
			case '\'': c = '\''; break;
			case '\"': c = '\"'; break;
			default:
				_os.put(c);
				return _os;
		}
		_os.put('\\');
		_os.put(c);
		return _os;
	}

	Node* Visit(SymbolType type, Node* p, PTNodeChildren& v)
	{
		MemoIterator i = p->end.find(type);
		assert(i != p->end.end());
		Node* pEnd = i->second;
		if (pEnd)
			v.push_back(PTNodeChild(type, p));
		return pEnd;
	}

	struct Private
	{
		static Node* Parse_AND(Node* p)
		{
			if (p->value == '&') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_CLOSE(Node* p)
		{
			if (p->value == ')') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_Char(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Char, 0));
			if (!r.second) return r.first->second;
			Node* b = p;
			if (p->value == '\\') ++p; else p = 0;
			if (p)
			{
				Node* b2 = p;
				if (p->value == 'n') ++p; else p = 0;
				if (!p)
				{
					p = b2;
					if (p->value == 'r') ++p; else p = 0;
					if (!p)
					{
						p = b2;
						if (p->value == 't') ++p; else p = 0;
						if (!p)
						{
							p = b2;
							if (p->value == '\'') ++p; else p = 0;
							if (!p)
							{
								p = b2;
								if (p->value == '\"') ++p; else p = 0;
								if (!p)
								{
									p = b2;
									if (p->value == '[') ++p; else p = 0;
									if (!p)
									{
										p = b2;
										if (p->value == ']') ++p; else p = 0;
										if (!p)
										{
											p = b2;
											if (p->value == '\\') ++p; else p = 0;
											if (!p)
											{
												p = b2;
												if (p->value >= '1' && p->value <= '9') ++p; else p = 0;
												if (p)
												{
													for (;;)
													{
														Node* b3 = p;
														if (p->value >= '0' && p->value <= '9') ++p; else p = 0;
														if (!p)
														{
															p = b3;
															break;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (!p)
			{
				p = b;
				if (p->value == '\\') ++p; else p = 0;
				if (p) p = 0; else p = b;
				if (p)
				{
					if (p->value != 0) ++p; else p = 0;
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Class(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Class, 0));
			if (!r.second) return r.first->second;
			if (p->value == '[') ++p; else p = 0;
			if (p)
			{
				for (;;)
				{
					Node* b = p;
					if (p->value == ']') ++p; else p = 0;
					if (p) p = 0; else p = b;
					if (p)
					{
						p = Parse_Range(p);
					}
					if (!p)
					{
						p = b;
						break;
					}
				}
				if (p)
				{
					if (p->value == ']') ++p; else p = 0;
					if (p)
					{
						p = Parse_Spacing(p);
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Comment(Node* p)
		{
			if (p->value == '#') ++p; else p = 0;
			if (p)
			{
				for (;;)
				{
					Node* b = p;
					p = Parse_EndOfLine(p);
					if (p) p = 0; else p = b;
					if (p)
					{
						if (p->value != 0) ++p; else p = 0;
					}
					if (!p)
					{
						p = b;
						break;
					}
				}
				if (p)
				{
					p = Parse_EndOfLine(p);
				}
			}
			return p;
		}

		static Node* Parse_DOT(Node* p)
		{
			if (p->value == '.') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_Definition(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Definition, 0));
			if (!r.second) return r.first->second;
			p = Parse_Identifier(p);
			if (p)
			{
				p = Parse_Spacing(p);
				if (p)
				{
					p = Parse_LEFTARROW(p);
					if (p)
					{
						p = Parse_Expression(p);
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_EndOfFile(Node* p)
		{
			Node* b = p;
			if (p->value != 0) ++p; else p = 0;
			if (p) p = 0; else p = b;
			return p;
		}

		static Node* Parse_EndOfLine(Node* p)
		{
			Node* b = p;
			if (p->value == '\r') ++p; else p = 0;
			if (p)
			{
				if (p->value == '\n') ++p; else p = 0;
			}
			if (!p)
			{
				p = b;
				if (p->value == '\n') ++p; else p = 0;
				if (!p)
				{
					p = b;
					if (p->value == '\r') ++p; else p = 0;
				}
			}
			return p;
		}

		static Node* Parse_Expression(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Expression, 0));
			if (!r.second) return r.first->second;
			p = Parse_Sequence(p);
			if (p)
			{
				for (;;)
				{
					Node* b = p;
					p = Parse_SLASH(p);
					if (p)
					{
						p = Parse_Sequence(p);
					}
					if (!p)
					{
						p = b;
						break;
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Grammar(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Grammar, 0));
			if (!r.second) return r.first->second;
			p = Parse_Spacing(p);
			if (p)
			{
				p = Parse_Definition(p);
				if (p)
				{
					for (;;)
					{
						Node* b = p;
						p = Parse_Definition(p);
						if (!p)
						{
							p = b;
							break;
						}
					}
					if (p)
					{
						p = Parse_EndOfFile(p);
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Identifier(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Identifier, 0));
			if (!r.second) return r.first->second;
			Node* b = p;
			if (p->value >= 'a' && p->value <= 'z') ++p; else p = 0;
			if (!p)
			{
				p = b;
				if (p->value >= 'A' && p->value <= 'Z') ++p; else p = 0;
				if (!p)
				{
					p = b;
					if (p->value == '_') ++p; else p = 0;
				}
			}
			if (p)
			{
				for (;;)
				{
					Node* b2 = p;
					if (p->value >= 'a' && p->value <= 'z') ++p; else p = 0;
					if (!p)
					{
						p = b2;
						if (p->value >= 'A' && p->value <= 'Z') ++p; else p = 0;
						if (!p)
						{
							p = b2;
							if (p->value >= '0' && p->value <= '9') ++p; else p = 0;
							if (!p)
							{
								p = b2;
								if (p->value == '_') ++p; else p = 0;
							}
						}
					}
					if (!p)
					{
						p = b2;
						break;
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_LEFTARROW(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_LEFTARROW, 0));
			if (!r.second) return r.first->second;
			if (p->value == '<') ++p; else p = 0;
			if (p)
			{
				Node* b = p;
				if (p->value == '-') ++p; else p = 0;
				if (!p)
				{
					p = b;
					if (p->value == '=') ++p; else p = 0;
					if (!p)
					{
						p = b;
						if (p->value == '<') ++p; else p = 0;
					}
				}
				if (p)
				{
					p = Parse_Spacing(p);
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Literal(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Literal, 0));
			if (!r.second) return r.first->second;
			Node* b = p;
			if (p->value == '\'') ++p; else p = 0;
			if (p)
			{
				for (;;)
				{
					Node* b2 = p;
					if (p->value == '\'') ++p; else p = 0;
					if (p) p = 0; else p = b2;
					if (p)
					{
						p = Parse_Char(p);
					}
					if (!p)
					{
						p = b2;
						break;
					}
				}
				if (p)
				{
					if (p->value == '\'') ++p; else p = 0;
					if (p)
					{
						p = Parse_Spacing(p);
					}
				}
			}
			if (!p)
			{
				p = b;
				if (p->value == '\"') ++p; else p = 0;
				if (p)
				{
					for (;;)
					{
						Node* b3 = p;
						if (p->value == '\"') ++p; else p = 0;
						if (p) p = 0; else p = b3;
						if (p)
						{
							p = Parse_Char(p);
						}
						if (!p)
						{
							p = b3;
							break;
						}
					}
					if (p)
					{
						if (p->value == '\"') ++p; else p = 0;
						if (p)
						{
							p = Parse_Spacing(p);
						}
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_NOT(Node* p)
		{
			if (p->value == '!') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_OPEN(Node* p)
		{
			if (p->value == '(') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_PLUS(Node* p)
		{
			if (p->value == '+') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_Prefix(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Prefix, 0));
			if (!r.second) return r.first->second;
			Node* b = p;
			p = Parse_AND(p);
			if (!p)
			{
				p = b;
				p = Parse_NOT(p);
				if (!p)
				{
					p = b;
				}
			}
			if (p)
			{
				p = Parse_Suffix(p);
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Primary(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Primary, 0));
			if (!r.second) return r.first->second;
			Node* b = p;
			p = Parse_Identifier(p);
			if (p)
			{
				p = Parse_Spacing(p);
				if (p)
				{
					Node* b2 = p;
					p = Parse_LEFTARROW(p);
					if (p) p = 0; else p = b2;
				}
			}
			if (!p)
			{
				p = b;
				p = Parse_OPEN(p);
				if (p)
				{
					p = Parse_Expression(p);
					if (p)
					{
						p = Parse_CLOSE(p);
					}
				}
				if (!p)
				{
					p = b;
					p = Parse_Literal(p);
					if (!p)
					{
						p = b;
						p = Parse_Class(p);
						if (!p)
						{
							p = b;
							p = Parse_DOT(p);
						}
					}
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_QUESTION(Node* p)
		{
			if (p->value == '?') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_Range(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Range, 0));
			if (!r.second) return r.first->second;
			p = Parse_Char(p);
			if (p)
			{
				Node* b = p;
				if (p->value == '-') ++p; else p = 0;
				if (p)
				{
					p = Parse_Char(p);
				}
				if (!p)
				{
					p = b;
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_SLASH(Node* p)
		{
			if (p->value == '/') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_STAR(Node* p)
		{
			if (p->value == '*') ++p; else p = 0;
			if (p)
			{
				p = Parse_Spacing(p);
			}
			return p;
		}

		static Node* Parse_Sequence(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Sequence, 0));
			if (!r.second) return r.first->second;
			for (;;)
			{
				Node* b = p;
				p = Parse_Prefix(p);
				if (!p)
				{
					p = b;
					break;
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Space(Node* p)
		{
			Node* b = p;
			if (p->value == ' ') ++p; else p = 0;
			if (!p)
			{
				p = b;
				if (p->value == '\t') ++p; else p = 0;
				if (!p)
				{
					p = b;
					p = Parse_EndOfLine(p);
				}
			}
			return p;
		}

		static Node* Parse_Spacing(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Spacing, 0));
			if (!r.second) return r.first->second;
			for (;;)
			{
				Node* b = p;
				p = Parse_Space(p);
				if (!p)
				{
					p = b;
					p = Parse_Comment(p);
				}
				if (!p)
				{
					p = b;
					break;
				}
			}
			r.first->second = p;
			return p;
		}

		static Node* Parse_Suffix(Node* p)
		{
			MemoInsertResult r = p->end.insert(Memo(SymbolType_Suffix, 0));
			if (!r.second) return r.first->second;
			p = Parse_Primary(p);
			if (p)
			{
				Node* b = p;
				p = Parse_QUESTION(p);
				if (!p)
				{
					p = b;
					p = Parse_STAR(p);
					if (!p)
					{
						p = b;
						p = Parse_PLUS(p);
						if (!p)
						{
							p = b;
						}
					}
				}
			}
			r.first->second = p;
			return p;
		}
								
		static Node* Traverse_Class(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Class(p);
			if (!e)
				return 0;
			if (p->value == '[') ++p; else p = 0;
			if (p)
			{
				for (;;)
				{
					Node* b = p;
					size_t s = v.size();
					if (p->value == ']') ++p; else p = 0;
					if (p) p = 0; else p = b;
					if (p)
					{
						p = ::Visit(SymbolType_Range, p, v);
					}
					if (!p)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						break;
					}
				}
				if (p)
				{
					if (p->value == ']') ++p; else p = 0;
					if (p)
					{
						p = Parse_Spacing(p);
					}
				}
			}
			return e;
		}
						
		static Node* Traverse_Definition(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Definition(p);
			if (!e)
				return 0;
			p = ::Visit(SymbolType_Identifier, p, v);
			if (p)
			{
				p = Parse_Spacing(p);
				if (p)
				{
					p = ::Visit(SymbolType_LEFTARROW, p, v);
					if (p)
					{
						p = ::Visit(SymbolType_Expression, p, v);
					}
				}
			}
			return e;
		}
						
		static Node* Traverse_Expression(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Expression(p);
			if (!e)
				return 0;
			p = ::Visit(SymbolType_Sequence, p, v);
			if (p)
			{
				for (;;)
				{
					Node* b = p;
					size_t s = v.size();
					p = Parse_SLASH(p);
					if (p)
					{
						p = ::Visit(SymbolType_Sequence, p, v);
					}
					if (!p)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						break;
					}
				}
			}
			return e;
		}
		
		static Node* Traverse_Grammar(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Grammar(p);
			if (!e)
				return 0;
			p = Parse_Spacing(p);
			if (p)
			{
				p = ::Visit(SymbolType_Definition, p, v);
				if (p)
				{
					for (;;)
					{
						Node* b = p;
						size_t s = v.size();
						p = ::Visit(SymbolType_Definition, p, v);
						if (!p)
						{
							p = b;
							v.erase(v.begin() + s, v.end());
							break;
						}
					}
					if (p)
					{
						p = Parse_EndOfFile(p);
					}
				}
			}
			return e;
		}
						
		static Node* Traverse_Literal(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Literal(p);
			if (!e)
				return 0;
			Node* b = p;
			size_t s = v.size();
			if (p->value == '\'') ++p; else p = 0;
			if (p)
			{
				for (;;)
				{
					Node* b2 = p;
					size_t s2 = v.size();
					if (p->value == '\'') ++p; else p = 0;
					if (p) p = 0; else p = b2;
					if (p)
					{
						p = ::Visit(SymbolType_Char, p, v);
					}
					if (!p)
					{
						p = b2;
						v.erase(v.begin() + s2, v.end());
						break;
					}
				}
				if (p)
				{
					if (p->value == '\'') ++p; else p = 0;
					if (p)
					{
						p = Parse_Spacing(p);
					}
				}
			}
			if (!p)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				if (p->value == '\"') ++p; else p = 0;
				if (p)
				{
					for (;;)
					{
						Node* b3 = p;
						size_t s3 = v.size();
						if (p->value == '\"') ++p; else p = 0;
						if (p) p = 0; else p = b3;
						if (p)
						{
							p = ::Visit(SymbolType_Char, p, v);
						}
						if (!p)
						{
							p = b3;
							v.erase(v.begin() + s3, v.end());
							break;
						}
					}
					if (p)
					{
						if (p->value == '\"') ++p; else p = 0;
						if (p)
						{
							p = Parse_Spacing(p);
						}
					}
				}
			}
			return e;
		}
								
		static Node* Traverse_Prefix(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Prefix(p);
			if (!e)
				return 0;
			Node* b = p;
			p = Parse_AND(p);
			if (!p)
			{
				p = b;
				p = Parse_NOT(p);
				if (!p)
				{
					p = b;
				}
			}
			if (p)
			{
				p = ::Visit(SymbolType_Suffix, p, v);
			}
			return e;
		}
		
		static Node* Traverse_Primary(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Primary(p);
			if (!e)
				return 0;
			Node* b = p;
			size_t s = v.size();
			p = ::Visit(SymbolType_Identifier, p, v);
			if (p)
			{
				p = Parse_Spacing(p);
				if (p)
				{
					Node* b2 = p;
					p = Parse_LEFTARROW(p);
					if (p) p = 0; else p = b2;
				}
			}
			if (!p)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				p = Parse_OPEN(p);
				if (p)
				{
					p = ::Visit(SymbolType_Expression, p, v);
					if (p)
					{
						p = Parse_CLOSE(p);
					}
				}
				if (!p)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					p = ::Visit(SymbolType_Literal, p, v);
					if (!p)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						p = ::Visit(SymbolType_Class, p, v);
						if (!p)
						{
							p = b;
							v.erase(v.begin() + s, v.end());
							p = Parse_DOT(p);
						}
					}
				}
			}
			return e;
		}
				
		static Node* Traverse_Range(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Range(p);
			if (!e)
				return 0;
			p = ::Visit(SymbolType_Char, p, v);
			if (p)
			{
				Node* b = p;
				size_t s = v.size();
				if (p->value == '-') ++p; else p = 0;
				if (p)
				{
					p = ::Visit(SymbolType_Char, p, v);
				}
				if (!p)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
				}
			}
			return e;
		}
						
		static Node* Traverse_Sequence(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Sequence(p);
			if (!e)
				return 0;
			for (;;)
			{
				Node* b = p;
				size_t s = v.size();
				p = ::Visit(SymbolType_Prefix, p, v);
				if (!p)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			return e;
		}
						
		static Node* Traverse_Suffix(Node* p, PTNodeChildren& v)
		{
			Node* e = Parse_Suffix(p);
			if (!e)
				return 0;
			p = ::Visit(SymbolType_Primary, p, v);
			if (p)
			{
				Node* b = p;
				p = Parse_QUESTION(p);
				if (!p)
				{
					p = b;
					p = Parse_STAR(p);
					if (!p)
					{
						p = b;
						p = Parse_PLUS(p);
						if (!p)
						{
							p = b;
						}
					}
				}
			}
			return e;
		}
	};
}

namespace PEGParser
{
	Node* Parse(SymbolType _type, Node* _symbol)
	{
		switch (_type)
		{
			case SymbolType_AND: return Private::Parse_AND(_symbol);
			case SymbolType_CLOSE: return Private::Parse_CLOSE(_symbol);
			case SymbolType_Char: return Private::Parse_Char(_symbol);
			case SymbolType_Class: return Private::Parse_Class(_symbol);
			case SymbolType_Comment: return Private::Parse_Comment(_symbol);
			case SymbolType_DOT: return Private::Parse_DOT(_symbol);
			case SymbolType_Definition: return Private::Parse_Definition(_symbol);
			case SymbolType_EndOfFile: return Private::Parse_EndOfFile(_symbol);
			case SymbolType_EndOfLine: return Private::Parse_EndOfLine(_symbol);
			case SymbolType_Expression: return Private::Parse_Expression(_symbol);
			case SymbolType_Grammar: return Private::Parse_Grammar(_symbol);
			case SymbolType_Identifier: return Private::Parse_Identifier(_symbol);
			case SymbolType_LEFTARROW: return Private::Parse_LEFTARROW(_symbol);
			case SymbolType_Literal: return Private::Parse_Literal(_symbol);
			case SymbolType_NOT: return Private::Parse_NOT(_symbol);
			case SymbolType_OPEN: return Private::Parse_OPEN(_symbol);
			case SymbolType_PLUS: return Private::Parse_PLUS(_symbol);
			case SymbolType_Prefix: return Private::Parse_Prefix(_symbol);
			case SymbolType_Primary: return Private::Parse_Primary(_symbol);
			case SymbolType_QUESTION: return Private::Parse_QUESTION(_symbol);
			case SymbolType_Range: return Private::Parse_Range(_symbol);
			case SymbolType_SLASH: return Private::Parse_SLASH(_symbol);
			case SymbolType_STAR: return Private::Parse_STAR(_symbol);
			case SymbolType_Sequence: return Private::Parse_Sequence(_symbol);
			case SymbolType_Space: return Private::Parse_Space(_symbol);
			case SymbolType_Spacing: return Private::Parse_Spacing(_symbol);
			case SymbolType_Suffix: return Private::Parse_Suffix(_symbol);
		}
		return 0;
	}

	Node* Traverse(SymbolType _type, Node* _symbol, PTNodeChildren& _children)
	{
		switch (_type)
		{
			case SymbolType_Class: return Private::Traverse_Class(_symbol, _children);
			case SymbolType_Definition: return Private::Traverse_Definition(_symbol, _children);
			case SymbolType_Expression: return Private::Traverse_Expression(_symbol, _children);
			case SymbolType_Grammar: return Private::Traverse_Grammar(_symbol, _children);
			case SymbolType_Literal: return Private::Traverse_Literal(_symbol, _children);
			case SymbolType_Prefix: return Private::Traverse_Prefix(_symbol, _children);
			case SymbolType_Primary: return Private::Traverse_Primary(_symbol, _children);
			case SymbolType_Range: return Private::Traverse_Range(_symbol, _children);
			case SymbolType_Sequence: return Private::Traverse_Sequence(_symbol, _children);
			case SymbolType_Suffix: return Private::Traverse_Suffix(_symbol, _children);
			case SymbolType_AND:
			case SymbolType_CLOSE:
			case SymbolType_Char:
			case SymbolType_Comment:
			case SymbolType_DOT:
			case SymbolType_EndOfFile:
			case SymbolType_EndOfLine:
			case SymbolType_Identifier:
			case SymbolType_LEFTARROW:
			case SymbolType_NOT:
			case SymbolType_OPEN:
			case SymbolType_PLUS:
			case SymbolType_QUESTION:
			case SymbolType_SLASH:
			case SymbolType_STAR:
			case SymbolType_Space:
			case SymbolType_Spacing:
			default:
				return Parse(_type, _symbol);
		}
	}

	const char* SymbolName(SymbolType _type)
	{
		switch (_type)
		{
			case SymbolType_AND: return "AND";
			case SymbolType_CLOSE: return "CLOSE";
			case SymbolType_Char: return "Char";
			case SymbolType_Class: return "Class";
			case SymbolType_Comment: return "Comment";
			case SymbolType_DOT: return "DOT";
			case SymbolType_Definition: return "Definition";
			case SymbolType_EndOfFile: return "EndOfFile";
			case SymbolType_EndOfLine: return "EndOfLine";
			case SymbolType_Expression: return "Expression";
			case SymbolType_Grammar: return "Grammar";
			case SymbolType_Identifier: return "Identifier";
			case SymbolType_LEFTARROW: return "LEFTARROW";
			case SymbolType_Literal: return "Literal";
			case SymbolType_NOT: return "NOT";
			case SymbolType_OPEN: return "OPEN";
			case SymbolType_PLUS: return "PLUS";
			case SymbolType_Prefix: return "Prefix";
			case SymbolType_Primary: return "Primary";
			case SymbolType_QUESTION: return "QUESTION";
			case SymbolType_Range: return "Range";
			case SymbolType_SLASH: return "SLASH";
			case SymbolType_STAR: return "STAR";
			case SymbolType_Sequence: return "Sequence";
			case SymbolType_Space: return "Space";
			case SymbolType_Spacing: return "Spacing";
			case SymbolType_Suffix: return "Suffix";
		}
	}

	void Print(std::ostream& _os, SymbolType _type, Node* _pNode, int _tabs, int _maxLineSize)
	{
		PTNodeChildren children;
		Node* pEnd = Traverse(_type, _pNode, children);
		if (!pEnd)
		{
			std::ostringstream oss;
			oss << "Parsing Failed for \"" << SymbolName(_type) << "\"";
			throw std::runtime_error(oss.str());
		}

		int tabCount = _tabs;
		while (tabCount--)
		  _os << "    ";

		_os << SymbolName(_type) << ": \"";

		size_t lineSize = 0;
		for (Node* p = _pNode; p != pEnd; ++p)
		{
			_os << EscapeChar(p->value);
			if (++lineSize >= _maxLineSize)
			{
				_os << "...";
				break;
			}
		}

		_os << "\"\n";

		for (PTNodeChildren::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
			Print(_os, i->first, i->second, _tabs + 1, _maxLineSize);
	}
}
