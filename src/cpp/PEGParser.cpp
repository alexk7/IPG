// This file was automatically generated by IPG on Mon Aug 29 20:48:31 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#ifndef BOOTSTRAP_TEST
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <boost/format.hpp>
#include <tr1/unordered_map>
#include <tr1/unordered_set>
#endif

#ifndef BOOTSTRAP_TEST
#include <vector>
#include <boost/shared_ptr.hpp>
#endif

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_CLASS,
		SymbolType_CLASS_1,
		SymbolType_Char,
		SymbolType_Definition,
		SymbolType_Expression,
		SymbolType_Expression_1,
		SymbolType_Grammar,
		SymbolType_Grammar_1,
		SymbolType_IDENTIFIER_1,
		SymbolType_Identifier,
		SymbolType_Item,
		SymbolType_Item_1,
		SymbolType_Item_2,
		SymbolType_LEFTARROW,
		SymbolType_LITERAL,
		SymbolType_LITERAL_1,
		SymbolType_Primary,
		SymbolType_Primary_1,
		SymbolType_Primary_2,
		SymbolType_Primary_3,
		SymbolType_Range,
		SymbolType_Sequence,
		SymbolTypeInvalid,
		SymbolTypeCount = SymbolTypeInvalid
	};

	struct Symbol
	{
		SymbolType type;
		size_t length;
		const char* value;
	};

	const char* SymbolName(SymbolType _type);

	class Context;

	class Iterator
	{
	public:
		friend Iterator Traverse(SymbolType _type, const char* _text);
		friend Iterator Traverse(const Iterator& _iParent);
		friend void DebugPrint(std::ostream& _os, const Iterator& _i, int _tabs, int _maxLineSize);

		Iterator();
		Iterator& operator++();
		const Symbol& operator*() const;
		const Symbol* operator->() const;

	private:
		Iterator(boost::shared_ptr<Context> _pContext, boost::shared_ptr< std::vector<Symbol> > _pSiblings);

		boost::shared_ptr<Context> mpContext;
		boost::shared_ptr< std::vector<Symbol> > mpSiblings;
		std::vector<Symbol>::iterator mi;
	};

	Iterator Traverse(SymbolType _type, const char* _text);
	Iterator Traverse(const Iterator& _iParent);
	void DebugPrint(std::ostream& _os, const Iterator& _i, int _tabs = 0, int _maxLineSize = 100);
}


using namespace std;
using namespace std::tr1;
using namespace boost;
using namespace PEGParser;
namespace
{
	typedef unordered_map<const char*, const char*> EndMap;
	typedef unordered_set<const char*> FailSet;

	struct EscapeChar
	{
		EscapeChar(char _c);
		char c;
	};

	EscapeChar::EscapeChar(char _c) : c(_c)
	{
	}

	ostream& operator<<(ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\n': c = 'n'; break;
			case '\r': c = 'r'; break;
			case '\t': c = 't'; break;

			case '\\':
			case '\'':
			case '\"':
				break;

			default:
				_os.put(c);
				return _os;
		}

		_os.put('\\');
		_os.put(c);
		return _os;
	}

	bool Parse(Context& _ctx, SymbolType _type, const char*& p);

	bool Parse_CLASS(Context& _ctx, const char*& p);
	bool Parse_CLASS_1(Context& _ctx, const char*& p);
	bool Parse_Char(Context& _ctx, const char*& p);
	bool Parse_Definition(Context& _ctx, const char*& p);
	bool Parse_Expression(Context& _ctx, const char*& p);
	bool Parse_Expression_1(Context& _ctx, const char*& p);
	bool Parse_Grammar(Context& _ctx, const char*& p);
	bool Parse_Grammar_1(Context& _ctx, const char*& p);
	bool Parse_IDENTIFIER_1(Context& _ctx, const char*& p);
	bool Parse_Identifier(Context& _ctx, const char*& p);
	bool Parse_Item(Context& _ctx, const char*& p);
	bool Parse_Item_1(Context& _ctx, const char*& p);
	bool Parse_Item_2(Context& _ctx, const char*& p);
	bool Parse_LEFTARROW(Context& _ctx, const char*& p);
	bool Parse_LITERAL(Context& _ctx, const char*& p);
	bool Parse_LITERAL_1(Context& _ctx, const char*& p);
	bool Parse_Primary(Context& _ctx, const char*& p);
	bool Parse_Primary_1(Context& _ctx, const char*& p);
	bool Parse_Primary_2(Context& _ctx, const char*& p);
	bool Parse_Primary_3(Context& _ctx, const char*& p);
	bool Parse_Range(Context& _ctx, const char*& p);
	bool Parse_Sequence(Context& _ctx, const char*& p);
}

const char* PEGParser::SymbolName(SymbolType _type)
{
	switch (_type)
	{
		case SymbolType_CLASS: return "CLASS";
		case SymbolType_CLASS_1: return "CLASS_1";
		case SymbolType_Char: return "Char";
		case SymbolType_Definition: return "Definition";
		case SymbolType_Expression: return "Expression";
		case SymbolType_Expression_1: return "Expression_1";
		case SymbolType_Grammar: return "Grammar";
		case SymbolType_Grammar_1: return "Grammar_1";
		case SymbolType_IDENTIFIER_1: return "IDENTIFIER_1";
		case SymbolType_Identifier: return "Identifier";
		case SymbolType_Item: return "Item";
		case SymbolType_Item_1: return "Item_1";
		case SymbolType_Item_2: return "Item_2";
		case SymbolType_LEFTARROW: return "LEFTARROW";
		case SymbolType_LITERAL: return "LITERAL";
		case SymbolType_LITERAL_1: return "LITERAL_1";
		case SymbolType_Primary: return "Primary";
		case SymbolType_Primary_1: return "Primary_1";
		case SymbolType_Primary_2: return "Primary_2";
		case SymbolType_Primary_3: return "Primary_3";
		case SymbolType_Range: return "Range";
		case SymbolType_Sequence: return "Sequence";
		default: throw runtime_error(str(format("Invalid Symbol Type: %1%") % _type));
	}
}

class PEGParser::Context
{
public:
	EndMap end[SymbolTypeCount];
	FailSet fail[SymbolTypeCount];

};
namespace
{
	bool Visit(Context& _ctx, SymbolType _type, const char*& _p, vector<Symbol>& _v)
	{
		const char* pBegin = _p;
		bool r = Parse(_ctx, _type, _p);
		if (r)
		{
			Symbol symbol = { _type, _p - pBegin, pBegin };
			_v.push_back(symbol);
		}
		return r;
	}

	bool Parse(Context& _ctx, SymbolType _type, const char*& p)
	{
		const char* pBegin = p;
		if (_ctx.fail[_type].count(pBegin))
			return false;
		EndMap::iterator i = _ctx.end[_type].find(pBegin);
		if (i != _ctx.end[_type].end())
		{
			p = i->second;
			return true;
		}

		bool r = true;
		switch (_type)
		{
			case SymbolType_CLASS: r = Parse_CLASS(_ctx, p); break;
			case SymbolType_CLASS_1: r = Parse_CLASS_1(_ctx, p); break;
			case SymbolType_Char: r = Parse_Char(_ctx, p); break;
			case SymbolType_Definition: r = Parse_Definition(_ctx, p); break;
			case SymbolType_Expression: r = Parse_Expression(_ctx, p); break;
			case SymbolType_Expression_1: r = Parse_Expression_1(_ctx, p); break;
			case SymbolType_Grammar: r = Parse_Grammar(_ctx, p); break;
			case SymbolType_Grammar_1: r = Parse_Grammar_1(_ctx, p); break;
			case SymbolType_IDENTIFIER_1: r = Parse_IDENTIFIER_1(_ctx, p); break;
			case SymbolType_Identifier: r = Parse_Identifier(_ctx, p); break;
			case SymbolType_Item: r = Parse_Item(_ctx, p); break;
			case SymbolType_Item_1: r = Parse_Item_1(_ctx, p); break;
			case SymbolType_Item_2: r = Parse_Item_2(_ctx, p); break;
			case SymbolType_LEFTARROW: r = Parse_LEFTARROW(_ctx, p); break;
			case SymbolType_LITERAL: r = Parse_LITERAL(_ctx, p); break;
			case SymbolType_LITERAL_1: r = Parse_LITERAL_1(_ctx, p); break;
			case SymbolType_Primary: r = Parse_Primary(_ctx, p); break;
			case SymbolType_Primary_1: r = Parse_Primary_1(_ctx, p); break;
			case SymbolType_Primary_2: r = Parse_Primary_2(_ctx, p); break;
			case SymbolType_Primary_3: r = Parse_Primary_3(_ctx, p); break;
			case SymbolType_Range: r = Parse_Range(_ctx, p); break;
			case SymbolType_Sequence: r = Parse_Sequence(_ctx, p); break;
			default:
				assert(false);
				return false;
		}

		if (r)
			_ctx.end[_type][pBegin] = p;
		else
			_ctx.fail[_type].insert(pBegin);
		return r;
	}

	bool Parse_CLASS(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == '[');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ']');
			r = !r;
			p = b;
			if (r)
			{
				r = Parse(_ctx, SymbolType_Range, p);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
		if (r)
		{
			r = Parse(_ctx, SymbolType_CLASS_1, p);
		}
	}
		return r;
	}

	bool Parse_CLASS_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == ']');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Char(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	c = *p++;
	r = (c == '\\');
	if (r)
	{
		const char* b2 = p;
		c = *p++;
		r = (c == 'n');
		if (!r)
		{
			p = b2;
			c = *p++;
			r = (c == 'r');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == 't');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\'');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\"');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '[');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == ']');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\\');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c >= '1' && c <= '9');
										if (r)
										{
											for (;;)
											{
												const char* b3 = p;
												c = *p++;
												r = (c >= '0' && c <= '9');
												if (!r)
												{
													p = b3;
													break;
												}
											}
											r = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\\');
		r = !r;
		p = b;
		if (r)
		{
			c = *p++;
			r = (c != 0);
		}
	}
		return r;
	}

	bool Parse_Definition(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	r = Parse(_ctx, SymbolType_Identifier, p);
	if (r)
	{
		r = Parse(_ctx, SymbolType_IDENTIFIER_1, p);
	}
	if (r)
	{
		r = Parse(_ctx, SymbolType_LEFTARROW, p);
		if (r)
		{
			r = Parse(_ctx, SymbolType_Expression, p);
		}
	}
		return r;
	}

	bool Parse_Expression(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	r = Parse(_ctx, SymbolType_Sequence, p);
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			r = Parse(_ctx, SymbolType_Expression_1, p);
			if (r)
			{
				r = Parse(_ctx, SymbolType_Sequence, p);
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Expression_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == '/');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Grammar(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	r = Parse(_ctx, SymbolType_Grammar_1, p);
	if (r)
	{
		r = Parse(_ctx, SymbolType_Definition, p);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				r = Parse(_ctx, SymbolType_Definition, p);
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c != 0);
				r = !r;
				p = b2;
			}
		}
	}
		return r;
	}

	bool Parse_Grammar_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
		return r;
	}

	bool Parse_IDENTIFIER_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
		return r;
	}

	bool Parse_Identifier(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	c = *p++;
	r = (c >= 'a' && c <= 'z');
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c >= 'A' && c <= 'Z');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '_');
		}
	}
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c >= '0' && c <= '9');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '_');
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Item(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	r = Parse(_ctx, SymbolType_Item_1, p);
	if (r)
	{
		r = Parse(_ctx, SymbolType_Primary, p);
		if (r)
		{
			r = Parse(_ctx, SymbolType_Item_2, p);
		}
	}
		return r;
	}

	bool Parse_Item_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	c = *p++;
	r = (c == '&');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '!');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
		return r;
	}

	bool Parse_Item_2(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	c = *p++;
	r = (c == '?');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '*');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '+');
			if (r)
			{
				for (;;)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b15 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b16 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b16;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											r = true;
										}
									}
								}
								r = !r;
								p = b16;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b16;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b18 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b18;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				r = true;
			}
		}
	}
		return r;
	}

	bool Parse_LEFTARROW(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == '<');
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '=');
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
							r = !r;
							p = b4;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b4;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b7 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b7;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
	}
		return r;
	}

	bool Parse_LITERAL(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	c = *p++;
	r = (c == '\'');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == '\'');
			r = !r;
			p = b2;
			if (r)
			{
				r = Parse(_ctx, SymbolType_Char, p);
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
		if (r)
		{
			c = *p++;
			r = (c == '\'');
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\"');
		if (r)
		{
			for (;;)
			{
				const char* b3 = p;
				c = *p++;
				r = (c == '\"');
				r = !r;
				p = b3;
				if (r)
				{
					r = Parse(_ctx, SymbolType_Char, p);
				}
				if (!r)
				{
					p = b3;
					break;
				}
			}
			r = true;
			if (r)
			{
				c = *p++;
				r = (c == '\"');
			}
		}
	}
	if (r)
	{
		r = Parse(_ctx, SymbolType_LITERAL_1, p);
	}
		return r;
	}

	bool Parse_LITERAL_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
		return r;
	}

	bool Parse_Primary(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	const char* b = p;
	r = Parse(_ctx, SymbolType_Identifier, p);
	if (r)
	{
		r = Parse(_ctx, SymbolType_IDENTIFIER_1, p);
	}
	if (r)
	{
		const char* b2 = p;
		r = Parse(_ctx, SymbolType_LEFTARROW, p);
		r = !r;
		p = b2;
	}
	if (!r)
	{
		p = b;
		r = Parse(_ctx, SymbolType_Primary_1, p);
		if (r)
		{
			r = Parse(_ctx, SymbolType_Expression, p);
			if (r)
			{
				r = Parse(_ctx, SymbolType_Primary_2, p);
			}
		}
		if (!r)
		{
			p = b;
			r = Parse(_ctx, SymbolType_LITERAL, p);
			if (!r)
			{
				p = b;
				r = Parse(_ctx, SymbolType_CLASS, p);
				if (!r)
				{
					p = b;
					r = Parse(_ctx, SymbolType_Primary_3, p);
				}
			}
		}
	}
		return r;
	}

	bool Parse_Primary_1(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == '(');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Primary_2(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == ')');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Primary_3(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	c = *p++;
	r = (c == '.');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
		return r;
	}

	bool Parse_Range(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	r = Parse(_ctx, SymbolType_Char, p);
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (r)
		{
			r = Parse(_ctx, SymbolType_Char, p);
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
		return r;
	}

	bool Parse_Sequence(Context& _ctx, const char*& p)
	{
		bool r = true;
		char c;
	for (;;)
	{
		const char* b = p;
		r = Parse(_ctx, SymbolType_Item, p);
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
		return r;
	}

	bool GetChildren(Context& _ctx, SymbolType _type, const char*& p, vector<Symbol>& v)
	{
		const char* pBegin = p;
		bool r = true;
		char c;
		switch (_type)
		{
			case SymbolType_CLASS:
			{
				if (_ctx.fail[SymbolType_CLASS].count(pBegin))
					return false;
	c = *p++;
	r = (c == '[');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			size_t s = v.size();
			c = *p++;
			r = (c == ']');
			r = !r;
			p = b;
			if (r)
			{
				r = Visit(_ctx, SymbolType_Range, p, v);
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				break;
			}
		}
		r = true;
		if (r)
		{
			r = GetChildren(_ctx, SymbolType_CLASS_1, p, v);
		}
	}
				if (r)
					_ctx.end[SymbolType_CLASS][pBegin] = p;
				else
					_ctx.fail[SymbolType_CLASS].insert(pBegin);
				return r;
			}

			case SymbolType_CLASS_1:
			{
				if (_ctx.fail[SymbolType_CLASS_1].count(pBegin))
					return false;
	c = *p++;
	r = (c == ']');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_CLASS_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_CLASS_1].insert(pBegin);
				return r;
			}

			case SymbolType_Char:
			{
				if (_ctx.fail[SymbolType_Char].count(pBegin))
					return false;
	const char* b = p;
	c = *p++;
	r = (c == '\\');
	if (r)
	{
		const char* b2 = p;
		c = *p++;
		r = (c == 'n');
		if (!r)
		{
			p = b2;
			c = *p++;
			r = (c == 'r');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == 't');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\'');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\"');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '[');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == ']');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\\');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c >= '1' && c <= '9');
										if (r)
										{
											for (;;)
											{
												const char* b3 = p;
												c = *p++;
												r = (c >= '0' && c <= '9');
												if (!r)
												{
													p = b3;
													break;
												}
											}
											r = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '\\');
		r = !r;
		p = b;
		if (r)
		{
			c = *p++;
			r = (c != 0);
		}
	}
				if (r)
					_ctx.end[SymbolType_Char][pBegin] = p;
				else
					_ctx.fail[SymbolType_Char].insert(pBegin);
				return r;
			}

			case SymbolType_Definition:
			{
				if (_ctx.fail[SymbolType_Definition].count(pBegin))
					return false;
	r = Visit(_ctx, SymbolType_Identifier, p, v);
	if (r)
	{
		r = GetChildren(_ctx, SymbolType_IDENTIFIER_1, p, v);
	}
	if (r)
	{
		r = Visit(_ctx, SymbolType_LEFTARROW, p, v);
		if (r)
		{
			r = Visit(_ctx, SymbolType_Expression, p, v);
		}
	}
				if (r)
					_ctx.end[SymbolType_Definition][pBegin] = p;
				else
					_ctx.fail[SymbolType_Definition].insert(pBegin);
				return r;
			}

			case SymbolType_Expression:
			{
				if (_ctx.fail[SymbolType_Expression].count(pBegin))
					return false;
	r = Visit(_ctx, SymbolType_Sequence, p, v);
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			size_t s = v.size();
			r = GetChildren(_ctx, SymbolType_Expression_1, p, v);
			if (r)
			{
				r = Visit(_ctx, SymbolType_Sequence, p, v);
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Expression][pBegin] = p;
				else
					_ctx.fail[SymbolType_Expression].insert(pBegin);
				return r;
			}

			case SymbolType_Expression_1:
			{
				if (_ctx.fail[SymbolType_Expression_1].count(pBegin))
					return false;
	c = *p++;
	r = (c == '/');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Expression_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_Expression_1].insert(pBegin);
				return r;
			}

			case SymbolType_Grammar:
			{
				if (_ctx.fail[SymbolType_Grammar].count(pBegin))
					return false;
	r = GetChildren(_ctx, SymbolType_Grammar_1, p, v);
	if (r)
	{
		r = Visit(_ctx, SymbolType_Definition, p, v);
		if (r)
		{
			for (;;)
			{
				const char* b = p;
				size_t s = v.size();
				r = Visit(_ctx, SymbolType_Definition, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c != 0);
				r = !r;
				p = b2;
			}
		}
	}
				if (r)
					_ctx.end[SymbolType_Grammar][pBegin] = p;
				else
					_ctx.fail[SymbolType_Grammar].insert(pBegin);
				return r;
			}

			case SymbolType_Grammar_1:
			{
				if (_ctx.fail[SymbolType_Grammar_1].count(pBegin))
					return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
				if (r)
					_ctx.end[SymbolType_Grammar_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_Grammar_1].insert(pBegin);
				return r;
			}

			case SymbolType_IDENTIFIER_1:
			{
				if (_ctx.fail[SymbolType_IDENTIFIER_1].count(pBegin))
					return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
				if (r)
					_ctx.end[SymbolType_IDENTIFIER_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_IDENTIFIER_1].insert(pBegin);
				return r;
			}

			case SymbolType_Identifier:
			{
				if (_ctx.fail[SymbolType_Identifier].count(pBegin))
					return false;
	const char* b = p;
	c = *p++;
	r = (c >= 'a' && c <= 'z');
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c >= 'A' && c <= 'Z');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '_');
		}
	}
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c >= '0' && c <= '9');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '_');
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Identifier][pBegin] = p;
				else
					_ctx.fail[SymbolType_Identifier].insert(pBegin);
				return r;
			}

			case SymbolType_Item:
			{
				if (_ctx.fail[SymbolType_Item].count(pBegin))
					return false;
	r = GetChildren(_ctx, SymbolType_Item_1, p, v);
	if (r)
	{
		r = Visit(_ctx, SymbolType_Primary, p, v);
		if (r)
		{
			r = GetChildren(_ctx, SymbolType_Item_2, p, v);
		}
	}
				if (r)
					_ctx.end[SymbolType_Item][pBegin] = p;
				else
					_ctx.fail[SymbolType_Item].insert(pBegin);
				return r;
			}

			case SymbolType_Item_1:
			{
				if (_ctx.fail[SymbolType_Item_1].count(pBegin))
					return false;
	const char* b = p;
	c = *p++;
	r = (c == '&');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '!');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			r = true;
		}
	}
				if (r)
					_ctx.end[SymbolType_Item_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_Item_1].insert(pBegin);
				return r;
			}

			case SymbolType_Item_2:
			{
				if (_ctx.fail[SymbolType_Item_2].count(pBegin))
					return false;
	const char* b = p;
	c = *p++;
	r = (c == '?');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b4 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									r = true;
								}
							}
						}
						r = !r;
						p = b4;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b4;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b6 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b6;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b7 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b7;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b2;
				break;
			}
		}
		r = true;
	}
	if (!r)
	{
		p = b;
		c = *p++;
		r = (c == '*');
		if (r)
		{
			for (;;)
			{
				const char* b8 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b8;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b9 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b10 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b10;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										r = true;
									}
								}
							}
							r = !r;
							p = b10;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b10;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b12 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b12;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b8;
					break;
				}
			}
			r = true;
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '+');
			if (r)
			{
				for (;;)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b15 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b16 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b16;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											r = true;
										}
									}
								}
								r = !r;
								p = b16;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b16;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b18 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b18;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b14;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				r = true;
			}
		}
	}
				if (r)
					_ctx.end[SymbolType_Item_2][pBegin] = p;
				else
					_ctx.fail[SymbolType_Item_2].insert(pBegin);
				return r;
			}

			case SymbolType_LEFTARROW:
			{
				if (_ctx.fail[SymbolType_LEFTARROW].count(pBegin))
					return false;
	c = *p++;
	r = (c == '<');
	if (r)
	{
		const char* b = p;
		c = *p++;
		r = (c == '-');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '=');
		}
		if (r)
		{
			for (;;)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
							r = !r;
							p = b4;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b4;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b7 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b7;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b2;
					break;
				}
			}
			r = true;
		}
	}
				if (r)
					_ctx.end[SymbolType_LEFTARROW][pBegin] = p;
				else
					_ctx.fail[SymbolType_LEFTARROW].insert(pBegin);
				return r;
			}

			case SymbolType_LITERAL:
			{
				if (_ctx.fail[SymbolType_LITERAL].count(pBegin))
					return false;
	const char* b = p;
	size_t s = v.size();
	c = *p++;
	r = (c == '\'');
	if (r)
	{
		for (;;)
		{
			const char* b2 = p;
			size_t s2 = v.size();
			c = *p++;
			r = (c == '\'');
			r = !r;
			p = b2;
			if (r)
			{
				r = Visit(_ctx, SymbolType_Char, p, v);
			}
			if (!r)
			{
				p = b2;
				v.erase(v.begin() + s2, v.end());
				break;
			}
		}
		r = true;
		if (r)
		{
			c = *p++;
			r = (c == '\'');
		}
	}
	if (!r)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		c = *p++;
		r = (c == '\"');
		if (r)
		{
			for (;;)
			{
				const char* b3 = p;
				size_t s3 = v.size();
				c = *p++;
				r = (c == '\"');
				r = !r;
				p = b3;
				if (r)
				{
					r = Visit(_ctx, SymbolType_Char, p, v);
				}
				if (!r)
				{
					p = b3;
					v.erase(v.begin() + s3, v.end());
					break;
				}
			}
			r = true;
			if (r)
			{
				c = *p++;
				r = (c == '\"');
			}
		}
	}
	if (r)
	{
		r = GetChildren(_ctx, SymbolType_LITERAL_1, p, v);
	}
				if (r)
					_ctx.end[SymbolType_LITERAL][pBegin] = p;
				else
					_ctx.fail[SymbolType_LITERAL].insert(pBegin);
				return r;
			}

			case SymbolType_LITERAL_1:
			{
				if (_ctx.fail[SymbolType_LITERAL_1].count(pBegin))
					return false;
	for (;;)
	{
		const char* b = p;
		c = *p++;
		r = (c == ' ');
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '\t');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\n');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\r');
					if (r)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b2;
							r = true;
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			c = *p++;
			r = (c == '#');
			if (r)
			{
				for (;;)
				{
					const char* b3 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b3;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b4 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								r = true;
							}
						}
					}
					r = !r;
					p = b3;
					if (r)
					{
						c = *p++;
						r = (c != 0);
					}
					if (!r)
					{
						p = b3;
						break;
					}
				}
				r = true;
				if (r)
				{
					const char* b5 = p;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b5;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b6 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b6;
								r = true;
							}
						}
					}
				}
			}
		}
		if (!r)
		{
			p = b;
			break;
		}
	}
	r = true;
				if (r)
					_ctx.end[SymbolType_LITERAL_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_LITERAL_1].insert(pBegin);
				return r;
			}

			case SymbolType_Primary:
			{
				if (_ctx.fail[SymbolType_Primary].count(pBegin))
					return false;
	const char* b = p;
	size_t s = v.size();
	r = Visit(_ctx, SymbolType_Identifier, p, v);
	if (r)
	{
		r = GetChildren(_ctx, SymbolType_IDENTIFIER_1, p, v);
	}
	if (r)
	{
		const char* b2 = p;
		r = Parse(_ctx, SymbolType_LEFTARROW, p);
		r = !r;
		p = b2;
	}
	if (!r)
	{
		p = b;
		v.erase(v.begin() + s, v.end());
		r = GetChildren(_ctx, SymbolType_Primary_1, p, v);
		if (r)
		{
			r = Visit(_ctx, SymbolType_Expression, p, v);
			if (r)
			{
				r = GetChildren(_ctx, SymbolType_Primary_2, p, v);
			}
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			r = Visit(_ctx, SymbolType_LITERAL, p, v);
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				r = Visit(_ctx, SymbolType_CLASS, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					r = GetChildren(_ctx, SymbolType_Primary_3, p, v);
				}
			}
		}
	}
				if (r)
					_ctx.end[SymbolType_Primary][pBegin] = p;
				else
					_ctx.fail[SymbolType_Primary].insert(pBegin);
				return r;
			}

			case SymbolType_Primary_1:
			{
				if (_ctx.fail[SymbolType_Primary_1].count(pBegin))
					return false;
	c = *p++;
	r = (c == '(');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Primary_1][pBegin] = p;
				else
					_ctx.fail[SymbolType_Primary_1].insert(pBegin);
				return r;
			}

			case SymbolType_Primary_2:
			{
				if (_ctx.fail[SymbolType_Primary_2].count(pBegin))
					return false;
	c = *p++;
	r = (c == ')');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Primary_2][pBegin] = p;
				else
					_ctx.fail[SymbolType_Primary_2].insert(pBegin);
				return r;
			}

			case SymbolType_Primary_3:
			{
				if (_ctx.fail[SymbolType_Primary_3].count(pBegin))
					return false;
	c = *p++;
	r = (c == '.');
	if (r)
	{
		for (;;)
		{
			const char* b = p;
			c = *p++;
			r = (c == ' ');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\t');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\n');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\r');
						if (r)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								r = true;
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '#');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b3;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									r = true;
								}
							}
						}
						r = !r;
						p = b3;
						if (r)
						{
							c = *p++;
							r = (c != 0);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b5 = p;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b5;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									r = true;
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				break;
			}
		}
		r = true;
	}
				if (r)
					_ctx.end[SymbolType_Primary_3][pBegin] = p;
				else
					_ctx.fail[SymbolType_Primary_3].insert(pBegin);
				return r;
			}

			case SymbolType_Range:
			{
				if (_ctx.fail[SymbolType_Range].count(pBegin))
					return false;
	r = Visit(_ctx, SymbolType_Char, p, v);
	if (r)
	{
		const char* b = p;
		size_t s = v.size();
		c = *p++;
		r = (c == '-');
		if (r)
		{
			r = Visit(_ctx, SymbolType_Char, p, v);
		}
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			r = true;
		}
	}
				if (r)
					_ctx.end[SymbolType_Range][pBegin] = p;
				else
					_ctx.fail[SymbolType_Range].insert(pBegin);
				return r;
			}

			case SymbolType_Sequence:
			{
				if (_ctx.fail[SymbolType_Sequence].count(pBegin))
					return false;
	for (;;)
	{
		const char* b = p;
		size_t s = v.size();
		r = Visit(_ctx, SymbolType_Item, p, v);
		if (!r)
		{
			p = b;
			v.erase(v.begin() + s, v.end());
			break;
		}
	}
	r = true;
				if (r)
					_ctx.end[SymbolType_Sequence][pBegin] = p;
				else
					_ctx.fail[SymbolType_Sequence].insert(pBegin);
				return r;
			}

			default:
				assert(false);
				return false;
		}
	}
	void DebugPrint(ostream& _os, Context& _ctx, SymbolType _type, const char* _pNode, int _tabs, int _maxLineSize)
	{
		vector<Symbol> children;
		const char* pEnd = _pNode;
		if (!GetChildren(_ctx, _type, pEnd, children))
			throw runtime_error(str(format("Parsing Failed for \"%1%\"") % SymbolName(_type)));

		int tabCount = _tabs;
		while (tabCount--)
			_os << "    ";

		_os << SymbolName(_type) << ": \"";

		size_t lineSize = 0;
		for (const char* p = _pNode; p != pEnd; ++p)
		{
			_os << EscapeChar(*p);
			if (++lineSize >= _maxLineSize)
			{
				_os << "...";
				break;
			}
		}

		_os << "\"\n";

		for (vector<Symbol>::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
			DebugPrint(_os, _ctx, i->type, i->value, _tabs + 1, _maxLineSize);
	//*
		if (_tabs == 0)
		{
			_os << "Memo Count:\n";
			for (size_t k = 0; k < SymbolTypeCount; ++k)
				_os << boost::format("%1% %|20t|End: %2% %|40t|Fail: %3%\n") % SymbolName(SymbolType(k)) % _ctx.end[k].size() % _ctx.fail[k].size();
		}
	//*/
	}
}

PEGParser::Iterator::Iterator()
{
}

Iterator& PEGParser::Iterator::operator++()
{
	assert(mpSiblings);
	if (++mi == mpSiblings->end())
		mpSiblings.reset();
	return *this;
}

const Symbol& PEGParser::Iterator::operator*() const
{
	static const Symbol invalidSymbol = { SymbolTypeInvalid };
	if (mpSiblings)
		return *mi;
	else
		return invalidSymbol;
}

const Symbol* PEGParser::Iterator::operator->() const
{
	return &**this;
}

PEGParser::Iterator::Iterator(shared_ptr<Context> _pContext, shared_ptr< vector<Symbol> > _pSiblings)
: mpContext(_pContext)
, mpSiblings(_pSiblings)
{
	if (_pSiblings)
		mi = _pSiblings->begin();
}

Iterator PEGParser::Traverse(SymbolType _type, const char* _text)
{
	shared_ptr<Context> pContext(new Context);
	const char* p = _text;
	if (Parse(*pContext, _type, p))
	{
		Symbol symbol = { _type, p - _text, _text };
		shared_ptr< vector<Symbol> > pSymbols(new vector<Symbol>(1, symbol));
		return Iterator(pContext, pSymbols);
	}
	return Iterator();
}

Iterator PEGParser::Traverse(const Iterator& _iParent)
{
	if (_iParent.mpSiblings)
	{
		const Symbol& symbol = *_iParent.mi;
		const char* p = symbol.value;
		vector<Symbol> children;
		bool r = GetChildren(*_iParent.mpContext, symbol.type, p, children);
		assert(r && p == symbol.value + symbol.length);
		boost::shared_ptr< vector<Symbol> > pChildren;
		if (!children.empty())
		{
			pChildren.reset(new vector<Symbol>);
			pChildren->swap(children);
		}
		return Iterator(_iParent.mpContext, pChildren);
	}
	return Iterator();
}

void PEGParser::DebugPrint(ostream& _os, const Iterator& _i, int _tabs, int _maxLineSize)
{
	if (_i.mpSiblings)
		::DebugPrint(_os, *_i.mpContext, _i.mi->type, _i.mi->value, _tabs, _maxLineSize);
}

