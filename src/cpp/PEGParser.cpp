// This file was automatically generated by IPG on Tue Aug  9 12:16:54 2011
// (from /Users/alexk7/ipg/build/xcode/../../src/peg/peg.peg)
// DO NOT EDIT!
#ifndef BOOTSTRAP_TEST
#include <cassert>
#include <stdexcept>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <boost/format.hpp>
#endif

#ifndef BOOTSTRAP_TEST
#include <vector>
#include <bitset>
#include <boost/shared_ptr.hpp>
#include <tr1/unordered_map>
#include <tr1/unordered_set>
#endif

namespace PEGParser
{
	enum SymbolType
	{
		SymbolType_CLASS,
		SymbolType_CLASS_1,
		SymbolType_Char,
		SymbolType_Definition,
		SymbolType_Expression,
		SymbolType_Expression_1,
		SymbolType_Grammar,
		SymbolType_Grammar_1,
		SymbolType_IDENTIFIER_1,
		SymbolType_Identifier,
		SymbolType_Item,
		SymbolType_Item_1,
		SymbolType_Item_2,
		SymbolType_LEFTARROW,
		SymbolType_LITERAL,
		SymbolType_LITERAL_1,
		SymbolType_Primary,
		SymbolType_Primary_1,
		SymbolType_Primary_2,
		SymbolType_Primary_3,
		SymbolType_Range,
		SymbolType_Sequence,
		SymbolTypeInvalid,
		SymbolTypeCount = SymbolTypeInvalid
	};

	typedef std::pair<SymbolType, const char*> Symbol;
	typedef std::vector<Symbol> Symbols;
	typedef std::tr1::unordered_map<const char*, const char*> EndMap;
	typedef std::tr1::unordered_set<const char*> FailSet;
	

	const char* SymbolName(SymbolType _type);

	class Parser
	{
	public:
		bool Parse(SymbolType _type, const char*& _p);
		bool Traverse(SymbolType _type, const char*& _p, Symbols& _children);
		void Print(std::ostream& _os, SymbolType _type, const char* _pNode, int _tabs = 0, int _maxLineSize = 100);

	private:
		bool Visit(SymbolType _type, const char*& _p, Symbols& _v);
		EndMap end[SymbolTypeCount];
		FailSet fail[SymbolTypeCount];
	};

	class Iterator
	{
	public:
		Iterator() {}
		bool IsA(SymbolType _type) const { return mpSiblings && mi->first == _type; }
		operator bool() const { return mpSiblings; }
		Iterator(boost::shared_ptr<Parser> _pParser, SymbolType _type, const char* _p) : mpParser(_pParser)
		{
			Symbols children;
			mpEnd = _p;
			if (_pParser->Traverse(_type, mpEnd, children))
			{
				mpSiblings.reset(new Symbols(1, Symbol(_type, _p)));
				mi = mpSiblings->begin();
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
		}
		Iterator& operator++()
		{
			assert(mpSiblings && mi != mpSiblings->end());
			mpChildren.reset();
			if (++mi == mpSiblings->end())
			{
				mpSiblings.reset();
			}
			else
			{
				Symbols children;
				mpEnd = mi->second;
				bool r = mpParser->Traverse(mi->first, mpEnd, children);
				assert(r);
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
			return *this;
		}
		const char* Begin() const
		{
			assert(mpSiblings && mi != mpSiblings->end());
			return mi->second;
		}
		const char* End() const
		{
			assert(mpSiblings && mi != mpSiblings->end());
			return mpEnd;
		}
		Iterator GetChild() const
		{
			return Iterator(mpParser, mpChildren);
		}
		Iterator GetChild(SymbolType _type) const
		{
			Iterator i = GetChild();
			assert(i.IsA(_type));
			return i;
		}
		void Print(std::ostream& _os, int _tabs = 0, int _maxLineSize = 100)
		{
			assert(mpSiblings && mi != mpSiblings->end());
			mpParser->Print(_os, mi->first, mi->second, _tabs, _maxLineSize);
		}
	private:
		Iterator(boost::shared_ptr<Parser> _pParser, boost::shared_ptr<Symbols> _pSiblings) : mpParser(_pParser), mpSiblings(_pSiblings)
		{
			if (_pSiblings)
			{
				mi = _pSiblings->begin();
				mpEnd = mi->second;
				Symbols children;
				bool r =_pParser->Traverse(mi->first, mpEnd, children);
				assert(r);
				if (!children.empty())
				{
					mpChildren.reset(new Symbols);
					mpChildren->swap(children);
				}
			}
		}
		boost::shared_ptr<Parser> mpParser;
		boost::shared_ptr<Symbols> mpSiblings, mpChildren;
		Symbols::iterator mi;
		const char* mpEnd;
	};

	std::ostream& operator<<(std::ostream& _os, const Iterator& _i);
}

namespace
{
	struct EscapeChar
	{
		EscapeChar(char _c);
		char c;
	};

	EscapeChar::EscapeChar(char _c) : c(_c)
	{
	}

	std::ostream& operator<<(std::ostream& _os, EscapeChar _e)
	{
		char c = _e.c;
		switch (c)
		{
			case '\n': c = 'n'; break;
			case '\r': c = 'r'; break;
			case '\t': c = 't'; break;

			case '\\':
			case '\'':
			case '\"':
				break;

			default:
				_os.put(c);
				return _os;
		}

		_os.put('\\');
		_os.put(c);
		return _os;
	}
}

const char* PEGParser::SymbolName(PEGParser::SymbolType _type)
{
	switch (_type)
	{
		case SymbolType_CLASS: return "CLASS";
		case SymbolType_CLASS_1: return "CLASS_1";
		case SymbolType_Char: return "Char";
		case SymbolType_Definition: return "Definition";
		case SymbolType_Expression: return "Expression";
		case SymbolType_Expression_1: return "Expression_1";
		case SymbolType_Grammar: return "Grammar";
		case SymbolType_Grammar_1: return "Grammar_1";
		case SymbolType_IDENTIFIER_1: return "IDENTIFIER_1";
		case SymbolType_Identifier: return "Identifier";
		case SymbolType_Item: return "Item";
		case SymbolType_Item_1: return "Item_1";
		case SymbolType_Item_2: return "Item_2";
		case SymbolType_LEFTARROW: return "LEFTARROW";
		case SymbolType_LITERAL: return "LITERAL";
		case SymbolType_LITERAL_1: return "LITERAL_1";
		case SymbolType_Primary: return "Primary";
		case SymbolType_Primary_1: return "Primary_1";
		case SymbolType_Primary_2: return "Primary_2";
		case SymbolType_Primary_3: return "Primary_3";
		case SymbolType_Range: return "Range";
		case SymbolType_Sequence: return "Sequence";
		default: throw std::runtime_error(str(boost::format("Invalid Symbol Type: %1%") % _type));
	}
}

bool PEGParser::Parser::Parse(SymbolType _type, const char*& p)
{
	const char* pBegin = p;
	bool r = true;
	char c;
	switch (_type)
	{
		case SymbolType_CLASS:
		{
			if (fail[SymbolType_CLASS].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_CLASS].find(pBegin);
			if (i != end[SymbolType_CLASS].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == '[');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ']');
					r = !r;
					p = b;
					if (r)
					{
						r = Parse(SymbolType_Range, p);
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
				if (r)
				{
					c = *p++;
					r = (c == ']');
					if (r)
					{
						for (;;)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b3 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b3;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b5 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b5;
													r = true;
												}
											}
										}
										r = !r;
										p = b4;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b4;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b7 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b7;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								break;
							}
						}
						r = true;
					}
				}
			}
			if (r)
				end[SymbolType_CLASS][pBegin] = p;
			else
				fail[SymbolType_CLASS].insert(pBegin);
			return r;
		}

		case SymbolType_CLASS_1:
		{
			if (fail[SymbolType_CLASS_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_CLASS_1].find(pBegin);
			if (i != end[SymbolType_CLASS_1].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == ']');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_CLASS_1][pBegin] = p;
			else
				fail[SymbolType_CLASS_1].insert(pBegin);
			return r;
		}

		case SymbolType_Char:
		{
			if (fail[SymbolType_Char].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Char].find(pBegin);
			if (i != end[SymbolType_Char].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c == '\\');
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == 'n');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == 'r');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == 't');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\'');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\"');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '[');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == ']');
										if (!r)
										{
											p = b2;
											c = *p++;
											r = (c == '\\');
											if (!r)
											{
												p = b2;
												c = *p++;
												r = (c >= '1' && c <= '9');
												if (r)
												{
													for (;;)
													{
														const char* b3 = p;
														c = *p++;
														r = (c >= '0' && c <= '9');
														if (!r)
														{
															p = b3;
															break;
														}
													}
													r = true;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\\');
				r = !r;
				p = b;
				if (r)
				{
					c = *p++;
					r = (c != 0);
				}
			}
			if (r)
				end[SymbolType_Char][pBegin] = p;
			else
				fail[SymbolType_Char].insert(pBegin);
			return r;
		}

		case SymbolType_Definition:
		{
			if (fail[SymbolType_Definition].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Definition].find(pBegin);
			if (i != end[SymbolType_Definition].end())
			{
				p = i->second;
				return true;
			}
			r = Parse(SymbolType_Identifier, p);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
			{
				r = Parse(SymbolType_LEFTARROW, p);
				if (r)
				{
					r = Parse(SymbolType_Expression, p);
				}
			}
			if (r)
				end[SymbolType_Definition][pBegin] = p;
			else
				fail[SymbolType_Definition].insert(pBegin);
			return r;
		}

		case SymbolType_Expression:
		{
			if (fail[SymbolType_Expression].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Expression].find(pBegin);
			if (i != end[SymbolType_Expression].end())
			{
				p = i->second;
				return true;
			}
			r = Parse(SymbolType_Sequence, p);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == '/');
					if (r)
					{
						for (;;)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b3 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b3;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b5 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b5;
													r = true;
												}
											}
										}
										r = !r;
										p = b4;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b4;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b7 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b7;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								break;
							}
						}
						r = true;
					}
					if (r)
					{
						r = Parse(SymbolType_Sequence, p);
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Expression][pBegin] = p;
			else
				fail[SymbolType_Expression].insert(pBegin);
			return r;
		}

		case SymbolType_Expression_1:
		{
			if (fail[SymbolType_Expression_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Expression_1].find(pBegin);
			if (i != end[SymbolType_Expression_1].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == '/');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Expression_1][pBegin] = p;
			else
				fail[SymbolType_Expression_1].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar:
		{
			if (fail[SymbolType_Grammar].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Grammar].find(pBegin);
			if (i != end[SymbolType_Grammar].end())
			{
				p = i->second;
				return true;
			}
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				r = Parse(SymbolType_Definition, p);
				if (r)
				{
					for (;;)
					{
						const char* b7 = p;
						r = Parse(SymbolType_Definition, p);
						if (!r)
						{
							p = b7;
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b8 = p;
						c = *p++;
						r = (c != 0);
						r = !r;
						p = b8;
					}
				}
			}
			if (r)
				end[SymbolType_Grammar][pBegin] = p;
			else
				fail[SymbolType_Grammar].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar_1:
		{
			if (fail[SymbolType_Grammar_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Grammar_1].find(pBegin);
			if (i != end[SymbolType_Grammar_1].end())
			{
				p = i->second;
				return true;
			}
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_Grammar_1][pBegin] = p;
			else
				fail[SymbolType_Grammar_1].insert(pBegin);
			return r;
		}

		case SymbolType_IDENTIFIER_1:
		{
			if (fail[SymbolType_IDENTIFIER_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_IDENTIFIER_1].find(pBegin);
			if (i != end[SymbolType_IDENTIFIER_1].end())
			{
				p = i->second;
				return true;
			}
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_IDENTIFIER_1][pBegin] = p;
			else
				fail[SymbolType_IDENTIFIER_1].insert(pBegin);
			return r;
		}

		case SymbolType_Identifier:
		{
			if (fail[SymbolType_Identifier].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Identifier].find(pBegin);
			if (i != end[SymbolType_Identifier].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '_');
				}
			}
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c >= 'a' && c <= 'z');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c >= 'A' && c <= 'Z');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c >= '0' && c <= '9');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '_');
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Identifier][pBegin] = p;
			else
				fail[SymbolType_Identifier].insert(pBegin);
			return r;
		}

		case SymbolType_Item:
		{
			if (fail[SymbolType_Item].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Item].find(pBegin);
			if (i != end[SymbolType_Item].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c == '&');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '!');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					r = true;
				}
			}
			if (r)
			{
				r = Parse(SymbolType_Primary, p);
				if (r)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == '?');
					if (r)
					{
						for (;;)
						{
							const char* b15 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b15;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b16 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b16;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b15;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b18 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b18;
													r = true;
												}
											}
										}
										r = !r;
										p = b17;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b17;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b20 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b20;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b15;
								break;
							}
						}
						r = true;
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '*');
						if (r)
						{
							for (;;)
							{
								const char* b21 = p;
								c = *p++;
								r = (c == ' ');
								if (!r)
								{
									p = b21;
									c = *p++;
									r = (c == '\t');
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b21;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b22 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b22;
													r = true;
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b21;
									c = *p++;
									r = (c == '#');
									if (r)
									{
										for (;;)
										{
											const char* b23 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b23;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b24 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b24;
														r = true;
													}
												}
											}
											r = !r;
											p = b23;
											if (r)
											{
												c = *p++;
												r = (c != 0);
											}
											if (!r)
											{
												p = b23;
												break;
											}
										}
										r = true;
										if (r)
										{
											const char* b25 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b25;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b26 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b26;
														r = true;
													}
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b21;
									break;
								}
							}
							r = true;
						}
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '+');
							if (r)
							{
								for (;;)
								{
									const char* b27 = p;
									c = *p++;
									r = (c == ' ');
									if (!r)
									{
										p = b27;
										c = *p++;
										r = (c == '\t');
										if (!r)
										{
											p = b27;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b27;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b28 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b28;
														r = true;
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b27;
										c = *p++;
										r = (c == '#');
										if (r)
										{
											for (;;)
											{
												const char* b29 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b29;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b30 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b30;
															r = true;
														}
													}
												}
												r = !r;
												p = b29;
												if (r)
												{
													c = *p++;
													r = (c != 0);
												}
												if (!r)
												{
													p = b29;
													break;
												}
											}
											r = true;
											if (r)
											{
												const char* b31 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b31;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b32 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b32;
															r = true;
														}
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b27;
										break;
									}
								}
								r = true;
							}
							if (!r)
							{
								p = b14;
								r = true;
							}
						}
					}
				}
			}
			if (r)
				end[SymbolType_Item][pBegin] = p;
			else
				fail[SymbolType_Item].insert(pBegin);
			return r;
		}

		case SymbolType_Item_1:
		{
			if (fail[SymbolType_Item_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Item_1].find(pBegin);
			if (i != end[SymbolType_Item_1].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c == '&');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '!');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					r = true;
				}
			}
			if (r)
				end[SymbolType_Item_1][pBegin] = p;
			else
				fail[SymbolType_Item_1].insert(pBegin);
			return r;
		}

		case SymbolType_Item_2:
		{
			if (fail[SymbolType_Item_2].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Item_2].find(pBegin);
			if (i != end[SymbolType_Item_2].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c == '?');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '*');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '+');
					if (r)
					{
						for (;;)
						{
							const char* b14 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b14;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b14;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b15 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b15;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b16 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b16;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b17 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b17;
													r = true;
												}
											}
										}
										r = !r;
										p = b16;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b16;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b18 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b18;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b19 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b19;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b14;
								break;
							}
						}
						r = true;
					}
					if (!r)
					{
						p = b;
						r = true;
					}
				}
			}
			if (r)
				end[SymbolType_Item_2][pBegin] = p;
			else
				fail[SymbolType_Item_2].insert(pBegin);
			return r;
		}

		case SymbolType_LEFTARROW:
		{
			if (fail[SymbolType_LEFTARROW].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_LEFTARROW].find(pBegin);
			if (i != end[SymbolType_LEFTARROW].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == '<');
			if (r)
			{
				const char* b = p;
				c = *p++;
				r = (c == '-');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '=');
				}
				if (r)
				{
					for (;;)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b3 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b3;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b5 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b5;
												r = true;
											}
										}
									}
									r = !r;
									p = b4;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b4;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b7 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b7;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b2;
							break;
						}
					}
					r = true;
				}
			}
			if (r)
				end[SymbolType_LEFTARROW][pBegin] = p;
			else
				fail[SymbolType_LEFTARROW].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL:
		{
			if (fail[SymbolType_LITERAL].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_LITERAL].find(pBegin);
			if (i != end[SymbolType_LITERAL].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			c = *p++;
			r = (c == '\'');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == '\'');
					r = !r;
					p = b2;
					if (r)
					{
						r = Parse(SymbolType_Char, p);
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
				if (r)
				{
					c = *p++;
					r = (c == '\'');
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\"');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						c = *p++;
						r = (c == '\"');
						r = !r;
						p = b3;
						if (r)
						{
							r = Parse(SymbolType_Char, p);
						}
						if (!r)
						{
							p = b3;
							break;
						}
					}
					r = true;
					if (r)
					{
						c = *p++;
						r = (c == '\"');
					}
				}
			}
			if (r)
			{
				for (;;)
				{
					const char* b4 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b4;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b4;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
								r = !r;
								p = b6;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b6;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b8 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b4;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_LITERAL][pBegin] = p;
			else
				fail[SymbolType_LITERAL].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL_1:
		{
			if (fail[SymbolType_LITERAL_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_LITERAL_1].find(pBegin);
			if (i != end[SymbolType_LITERAL_1].end())
			{
				p = i->second;
				return true;
			}
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_LITERAL_1][pBegin] = p;
			else
				fail[SymbolType_LITERAL_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary:
		{
			if (fail[SymbolType_Primary].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Primary].find(pBegin);
			if (i != end[SymbolType_Primary].end())
			{
				p = i->second;
				return true;
			}
			const char* b = p;
			r = Parse(SymbolType_Identifier, p);
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (r)
			{
				const char* b8 = p;
				r = Parse(SymbolType_LEFTARROW, p);
				r = !r;
				p = b8;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '(');
				if (r)
				{
					for (;;)
					{
						const char* b9 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b9;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b9;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b10 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b10;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b9;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b12 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b12;
												r = true;
											}
										}
									}
									r = !r;
									p = b11;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b11;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b14 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b14;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b9;
							break;
						}
					}
					r = true;
				}
				if (r)
				{
					r = Parse(SymbolType_Expression, p);
					if (r)
					{
						c = *p++;
						r = (c == ')');
						if (r)
						{
							for (;;)
							{
								const char* b15 = p;
								c = *p++;
								r = (c == ' ');
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '\t');
									if (!r)
									{
										p = b15;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b15;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b16 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b16;
													r = true;
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '#');
									if (r)
									{
										for (;;)
										{
											const char* b17 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b17;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b18 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b18;
														r = true;
													}
												}
											}
											r = !r;
											p = b17;
											if (r)
											{
												c = *p++;
												r = (c != 0);
											}
											if (!r)
											{
												p = b17;
												break;
											}
										}
										r = true;
										if (r)
										{
											const char* b19 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b19;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b20 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b20;
														r = true;
													}
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b15;
									break;
								}
							}
							r = true;
						}
					}
				}
				if (!r)
				{
					p = b;
					r = Parse(SymbolType_LITERAL, p);
					if (!r)
					{
						p = b;
						r = Parse(SymbolType_CLASS, p);
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '.');
							if (r)
							{
								for (;;)
								{
									const char* b21 = p;
									c = *p++;
									r = (c == ' ');
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '\t');
										if (!r)
										{
											p = b21;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b21;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b22 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b22;
														r = true;
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '#');
										if (r)
										{
											for (;;)
											{
												const char* b23 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b23;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b24 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b24;
															r = true;
														}
													}
												}
												r = !r;
												p = b23;
												if (r)
												{
													c = *p++;
													r = (c != 0);
												}
												if (!r)
												{
													p = b23;
													break;
												}
											}
											r = true;
											if (r)
											{
												const char* b25 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b25;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b26 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b26;
															r = true;
														}
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b21;
										break;
									}
								}
								r = true;
							}
						}
					}
				}
			}
			if (r)
				end[SymbolType_Primary][pBegin] = p;
			else
				fail[SymbolType_Primary].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_1:
		{
			if (fail[SymbolType_Primary_1].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Primary_1].find(pBegin);
			if (i != end[SymbolType_Primary_1].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == '(');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_1][pBegin] = p;
			else
				fail[SymbolType_Primary_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_2:
		{
			if (fail[SymbolType_Primary_2].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Primary_2].find(pBegin);
			if (i != end[SymbolType_Primary_2].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == ')');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_2][pBegin] = p;
			else
				fail[SymbolType_Primary_2].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_3:
		{
			if (fail[SymbolType_Primary_3].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Primary_3].find(pBegin);
			if (i != end[SymbolType_Primary_3].end())
			{
				p = i->second;
				return true;
			}
			c = *p++;
			r = (c == '.');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_3][pBegin] = p;
			else
				fail[SymbolType_Primary_3].insert(pBegin);
			return r;
		}

		case SymbolType_Range:
		{
			if (fail[SymbolType_Range].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Range].find(pBegin);
			if (i != end[SymbolType_Range].end())
			{
				p = i->second;
				return true;
			}
			r = Parse(SymbolType_Char, p);
			if (r)
			{
				const char* b = p;
				c = *p++;
				r = (c == '-');
				if (r)
				{
					r = Parse(SymbolType_Char, p);
				}
				if (!r)
				{
					p = b;
					r = true;
				}
			}
			if (r)
				end[SymbolType_Range][pBegin] = p;
			else
				fail[SymbolType_Range].insert(pBegin);
			return r;
		}

		case SymbolType_Sequence:
		{
			if (fail[SymbolType_Sequence].count(pBegin))
				return false;
			EndMap::iterator i = end[SymbolType_Sequence].find(pBegin);
			if (i != end[SymbolType_Sequence].end())
			{
				p = i->second;
				return true;
			}
			for (;;)
			{
				const char* b = p;
				r = Parse(SymbolType_Item, p);
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_Sequence][pBegin] = p;
			else
				fail[SymbolType_Sequence].insert(pBegin);
			return r;
		}

		default:
			assert(false);
			return false;
	}
}

bool PEGParser::Parser::Traverse(PEGParser::SymbolType _type, const char*& p, PEGParser::Symbols& v)
{
	const char* pBegin = p;
	bool r = true;
	char c;
	switch (_type)
	{
		case SymbolType_CLASS:
		{
			if (fail[SymbolType_CLASS].count(pBegin))
				return false;
			c = *p++;
			r = (c == '[');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					size_t s = v.size();
					c = *p++;
					r = (c == ']');
					r = !r;
					p = b;
					if (r)
					{
						r = Visit(SymbolType_Range, p, v);
					}
					if (!r)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						break;
					}
				}
				r = true;
				if (r)
				{
					c = *p++;
					r = (c == ']');
					if (r)
					{
						for (;;)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b3 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b3;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b5 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b5;
													r = true;
												}
											}
										}
										r = !r;
										p = b4;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b4;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b7 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b7;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								break;
							}
						}
						r = true;
					}
				}
			}
			if (r)
				end[SymbolType_CLASS][pBegin] = p;
			else
				fail[SymbolType_CLASS].insert(pBegin);
			return r;
		}

		case SymbolType_CLASS_1:
		{
			if (fail[SymbolType_CLASS_1].count(pBegin))
				return false;
			c = *p++;
			r = (c == ']');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_CLASS_1][pBegin] = p;
			else
				fail[SymbolType_CLASS_1].insert(pBegin);
			return r;
		}

		case SymbolType_Char:
		{
			if (fail[SymbolType_Char].count(pBegin))
				return false;
			const char* b = p;
			c = *p++;
			r = (c == '\\');
			if (r)
			{
				const char* b2 = p;
				c = *p++;
				r = (c == 'n');
				if (!r)
				{
					p = b2;
					c = *p++;
					r = (c == 'r');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == 't');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\'');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\"');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '[');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == ']');
										if (!r)
										{
											p = b2;
											c = *p++;
											r = (c == '\\');
											if (!r)
											{
												p = b2;
												c = *p++;
												r = (c >= '1' && c <= '9');
												if (r)
												{
													for (;;)
													{
														const char* b3 = p;
														c = *p++;
														r = (c >= '0' && c <= '9');
														if (!r)
														{
															p = b3;
															break;
														}
													}
													r = true;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '\\');
				r = !r;
				p = b;
				if (r)
				{
					c = *p++;
					r = (c != 0);
				}
			}
			if (r)
				end[SymbolType_Char][pBegin] = p;
			else
				fail[SymbolType_Char].insert(pBegin);
			return r;
		}

		case SymbolType_Definition:
		{
			if (fail[SymbolType_Definition].count(pBegin))
				return false;
			r = Visit(SymbolType_Identifier, p, v);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
			{
				r = Visit(SymbolType_LEFTARROW, p, v);
				if (r)
				{
					r = Visit(SymbolType_Expression, p, v);
				}
			}
			if (r)
				end[SymbolType_Definition][pBegin] = p;
			else
				fail[SymbolType_Definition].insert(pBegin);
			return r;
		}

		case SymbolType_Expression:
		{
			if (fail[SymbolType_Expression].count(pBegin))
				return false;
			r = Visit(SymbolType_Sequence, p, v);
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					size_t s = v.size();
					c = *p++;
					r = (c == '/');
					if (r)
					{
						for (;;)
						{
							const char* b2 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b3 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b3;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b5 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b5;
													r = true;
												}
											}
										}
										r = !r;
										p = b4;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b4;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b7 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b7;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b2;
								break;
							}
						}
						r = true;
					}
					if (r)
					{
						r = Visit(SymbolType_Sequence, p, v);
					}
					if (!r)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Expression][pBegin] = p;
			else
				fail[SymbolType_Expression].insert(pBegin);
			return r;
		}

		case SymbolType_Expression_1:
		{
			if (fail[SymbolType_Expression_1].count(pBegin))
				return false;
			c = *p++;
			r = (c == '/');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Expression_1][pBegin] = p;
			else
				fail[SymbolType_Expression_1].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar:
		{
			if (fail[SymbolType_Grammar].count(pBegin))
				return false;
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
			{
				r = Visit(SymbolType_Definition, p, v);
				if (r)
				{
					for (;;)
					{
						const char* b7 = p;
						size_t s7 = v.size();
						r = Visit(SymbolType_Definition, p, v);
						if (!r)
						{
							p = b7;
							v.erase(v.begin() + s7, v.end());
							break;
						}
					}
					r = true;
					if (r)
					{
						const char* b8 = p;
						c = *p++;
						r = (c != 0);
						r = !r;
						p = b8;
					}
				}
			}
			if (r)
				end[SymbolType_Grammar][pBegin] = p;
			else
				fail[SymbolType_Grammar].insert(pBegin);
			return r;
		}

		case SymbolType_Grammar_1:
		{
			if (fail[SymbolType_Grammar_1].count(pBegin))
				return false;
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_Grammar_1][pBegin] = p;
			else
				fail[SymbolType_Grammar_1].insert(pBegin);
			return r;
		}

		case SymbolType_IDENTIFIER_1:
		{
			if (fail[SymbolType_IDENTIFIER_1].count(pBegin))
				return false;
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_IDENTIFIER_1][pBegin] = p;
			else
				fail[SymbolType_IDENTIFIER_1].insert(pBegin);
			return r;
		}

		case SymbolType_Identifier:
		{
			if (fail[SymbolType_Identifier].count(pBegin))
				return false;
			const char* b = p;
			c = *p++;
			r = (c >= 'a' && c <= 'z');
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c >= 'A' && c <= 'Z');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '_');
				}
			}
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c >= 'a' && c <= 'z');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c >= 'A' && c <= 'Z');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c >= '0' && c <= '9');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '_');
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Identifier][pBegin] = p;
			else
				fail[SymbolType_Identifier].insert(pBegin);
			return r;
		}

		case SymbolType_Item:
		{
			if (fail[SymbolType_Item].count(pBegin))
				return false;
			const char* b = p;
			c = *p++;
			r = (c == '&');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '!');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					r = true;
				}
			}
			if (r)
			{
				r = Visit(SymbolType_Primary, p, v);
				if (r)
				{
					const char* b14 = p;
					c = *p++;
					r = (c == '?');
					if (r)
					{
						for (;;)
						{
							const char* b15 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b15;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b15;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b16 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b16;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b15;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b17 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b17;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b18 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b18;
													r = true;
												}
											}
										}
										r = !r;
										p = b17;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b17;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b19 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b19;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b20 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b20;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b15;
								break;
							}
						}
						r = true;
					}
					if (!r)
					{
						p = b14;
						c = *p++;
						r = (c == '*');
						if (r)
						{
							for (;;)
							{
								const char* b21 = p;
								c = *p++;
								r = (c == ' ');
								if (!r)
								{
									p = b21;
									c = *p++;
									r = (c == '\t');
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b21;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b22 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b22;
													r = true;
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b21;
									c = *p++;
									r = (c == '#');
									if (r)
									{
										for (;;)
										{
											const char* b23 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b23;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b24 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b24;
														r = true;
													}
												}
											}
											r = !r;
											p = b23;
											if (r)
											{
												c = *p++;
												r = (c != 0);
											}
											if (!r)
											{
												p = b23;
												break;
											}
										}
										r = true;
										if (r)
										{
											const char* b25 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b25;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b26 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b26;
														r = true;
													}
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b21;
									break;
								}
							}
							r = true;
						}
						if (!r)
						{
							p = b14;
							c = *p++;
							r = (c == '+');
							if (r)
							{
								for (;;)
								{
									const char* b27 = p;
									c = *p++;
									r = (c == ' ');
									if (!r)
									{
										p = b27;
										c = *p++;
										r = (c == '\t');
										if (!r)
										{
											p = b27;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b27;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b28 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b28;
														r = true;
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b27;
										c = *p++;
										r = (c == '#');
										if (r)
										{
											for (;;)
											{
												const char* b29 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b29;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b30 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b30;
															r = true;
														}
													}
												}
												r = !r;
												p = b29;
												if (r)
												{
													c = *p++;
													r = (c != 0);
												}
												if (!r)
												{
													p = b29;
													break;
												}
											}
											r = true;
											if (r)
											{
												const char* b31 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b31;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b32 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b32;
															r = true;
														}
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b27;
										break;
									}
								}
								r = true;
							}
							if (!r)
							{
								p = b14;
								r = true;
							}
						}
					}
				}
			}
			if (r)
				end[SymbolType_Item][pBegin] = p;
			else
				fail[SymbolType_Item].insert(pBegin);
			return r;
		}

		case SymbolType_Item_1:
		{
			if (fail[SymbolType_Item_1].count(pBegin))
				return false;
			const char* b = p;
			c = *p++;
			r = (c == '&');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '!');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					r = true;
				}
			}
			if (r)
				end[SymbolType_Item_1][pBegin] = p;
			else
				fail[SymbolType_Item_1].insert(pBegin);
			return r;
		}

		case SymbolType_Item_2:
		{
			if (fail[SymbolType_Item_2].count(pBegin))
				return false;
			const char* b = p;
			c = *p++;
			r = (c == '?');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (!r)
			{
				p = b;
				c = *p++;
				r = (c == '*');
				if (r)
				{
					for (;;)
					{
						const char* b8 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b8;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b10 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b10;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b11 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b11;
												r = true;
											}
										}
									}
									r = !r;
									p = b10;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b10;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b12 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b12;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b13 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b13;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b8;
							break;
						}
					}
					r = true;
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '+');
					if (r)
					{
						for (;;)
						{
							const char* b14 = p;
							c = *p++;
							r = (c == ' ');
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '\t');
								if (!r)
								{
									p = b14;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b14;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b15 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b15;
												r = true;
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b14;
								c = *p++;
								r = (c == '#');
								if (r)
								{
									for (;;)
									{
										const char* b16 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b16;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b17 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b17;
													r = true;
												}
											}
										}
										r = !r;
										p = b16;
										if (r)
										{
											c = *p++;
											r = (c != 0);
										}
										if (!r)
										{
											p = b16;
											break;
										}
									}
									r = true;
									if (r)
									{
										const char* b18 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b18;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b19 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b19;
													r = true;
												}
											}
										}
									}
								}
							}
							if (!r)
							{
								p = b14;
								break;
							}
						}
						r = true;
					}
					if (!r)
					{
						p = b;
						r = true;
					}
				}
			}
			if (r)
				end[SymbolType_Item_2][pBegin] = p;
			else
				fail[SymbolType_Item_2].insert(pBegin);
			return r;
		}

		case SymbolType_LEFTARROW:
		{
			if (fail[SymbolType_LEFTARROW].count(pBegin))
				return false;
			c = *p++;
			r = (c == '<');
			if (r)
			{
				const char* b = p;
				c = *p++;
				r = (c == '-');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '=');
				}
				if (r)
				{
					for (;;)
					{
						const char* b2 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b3 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b3;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b5 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b5;
												r = true;
											}
										}
									}
									r = !r;
									p = b4;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b4;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b7 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b7;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b2;
							break;
						}
					}
					r = true;
				}
			}
			if (r)
				end[SymbolType_LEFTARROW][pBegin] = p;
			else
				fail[SymbolType_LEFTARROW].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL:
		{
			if (fail[SymbolType_LITERAL].count(pBegin))
				return false;
			const char* b = p;
			size_t s = v.size();
			c = *p++;
			r = (c == '\'');
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					size_t s2 = v.size();
					c = *p++;
					r = (c == '\'');
					r = !r;
					p = b2;
					if (r)
					{
						r = Visit(SymbolType_Char, p, v);
					}
					if (!r)
					{
						p = b2;
						v.erase(v.begin() + s2, v.end());
						break;
					}
				}
				r = true;
				if (r)
				{
					c = *p++;
					r = (c == '\'');
				}
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				c = *p++;
				r = (c == '\"');
				if (r)
				{
					for (;;)
					{
						const char* b3 = p;
						size_t s3 = v.size();
						c = *p++;
						r = (c == '\"');
						r = !r;
						p = b3;
						if (r)
						{
							r = Visit(SymbolType_Char, p, v);
						}
						if (!r)
						{
							p = b3;
							v.erase(v.begin() + s3, v.end());
							break;
						}
					}
					r = true;
					if (r)
					{
						c = *p++;
						r = (c == '\"');
					}
				}
			}
			if (r)
			{
				for (;;)
				{
					const char* b4 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b4;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b4;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b4;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b5 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b5;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b4;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
								r = !r;
								p = b6;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b6;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b8 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b8;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b9 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b9;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b4;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_LITERAL][pBegin] = p;
			else
				fail[SymbolType_LITERAL].insert(pBegin);
			return r;
		}

		case SymbolType_LITERAL_1:
		{
			if (fail[SymbolType_LITERAL_1].count(pBegin))
				return false;
			for (;;)
			{
				const char* b = p;
				c = *p++;
				r = (c == ' ');
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '\t');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\n');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\r');
							if (r)
							{
								const char* b2 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b2;
									r = true;
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					c = *p++;
					r = (c == '#');
					if (r)
					{
						for (;;)
						{
							const char* b3 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b3;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b4 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b4;
										r = true;
									}
								}
							}
							r = !r;
							p = b3;
							if (r)
							{
								c = *p++;
								r = (c != 0);
							}
							if (!r)
							{
								p = b3;
								break;
							}
						}
						r = true;
						if (r)
						{
							const char* b5 = p;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b5;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b6 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b6;
										r = true;
									}
								}
							}
						}
					}
				}
				if (!r)
				{
					p = b;
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_LITERAL_1][pBegin] = p;
			else
				fail[SymbolType_LITERAL_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary:
		{
			if (fail[SymbolType_Primary].count(pBegin))
				return false;
			const char* b = p;
			size_t s = v.size();
			r = Visit(SymbolType_Identifier, p, v);
			if (r)
			{
				for (;;)
				{
					const char* b2 = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b2;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b2;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b3 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b3;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b4 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b4;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b5 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b5;
											r = true;
										}
									}
								}
								r = !r;
								p = b4;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b4;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b6 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b6;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b7 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b7;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b2;
						break;
					}
				}
				r = true;
			}
			if (r)
			{
				const char* b8 = p;
				r = Parse(SymbolType_LEFTARROW, p);
				r = !r;
				p = b8;
			}
			if (!r)
			{
				p = b;
				v.erase(v.begin() + s, v.end());
				c = *p++;
				r = (c == '(');
				if (r)
				{
					for (;;)
					{
						const char* b9 = p;
						c = *p++;
						r = (c == ' ');
						if (!r)
						{
							p = b9;
							c = *p++;
							r = (c == '\t');
							if (!r)
							{
								p = b9;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b9;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b10 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b10;
											r = true;
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b9;
							c = *p++;
							r = (c == '#');
							if (r)
							{
								for (;;)
								{
									const char* b11 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b11;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b12 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b12;
												r = true;
											}
										}
									}
									r = !r;
									p = b11;
									if (r)
									{
										c = *p++;
										r = (c != 0);
									}
									if (!r)
									{
										p = b11;
										break;
									}
								}
								r = true;
								if (r)
								{
									const char* b13 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b13;
										c = *p++;
										r = (c == '\r');
										if (r)
										{
											const char* b14 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b14;
												r = true;
											}
										}
									}
								}
							}
						}
						if (!r)
						{
							p = b9;
							break;
						}
					}
					r = true;
				}
				if (r)
				{
					r = Visit(SymbolType_Expression, p, v);
					if (r)
					{
						c = *p++;
						r = (c == ')');
						if (r)
						{
							for (;;)
							{
								const char* b15 = p;
								c = *p++;
								r = (c == ' ');
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '\t');
									if (!r)
									{
										p = b15;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b15;
											c = *p++;
											r = (c == '\r');
											if (r)
											{
												const char* b16 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b16;
													r = true;
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b15;
									c = *p++;
									r = (c == '#');
									if (r)
									{
										for (;;)
										{
											const char* b17 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b17;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b18 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b18;
														r = true;
													}
												}
											}
											r = !r;
											p = b17;
											if (r)
											{
												c = *p++;
												r = (c != 0);
											}
											if (!r)
											{
												p = b17;
												break;
											}
										}
										r = true;
										if (r)
										{
											const char* b19 = p;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b19;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b20 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b20;
														r = true;
													}
												}
											}
										}
									}
								}
								if (!r)
								{
									p = b15;
									break;
								}
							}
							r = true;
						}
					}
				}
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					r = Visit(SymbolType_LITERAL, p, v);
					if (!r)
					{
						p = b;
						v.erase(v.begin() + s, v.end());
						r = Visit(SymbolType_CLASS, p, v);
						if (!r)
						{
							p = b;
							v.erase(v.begin() + s, v.end());
							c = *p++;
							r = (c == '.');
							if (r)
							{
								for (;;)
								{
									const char* b21 = p;
									c = *p++;
									r = (c == ' ');
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '\t');
										if (!r)
										{
											p = b21;
											c = *p++;
											r = (c == '\n');
											if (!r)
											{
												p = b21;
												c = *p++;
												r = (c == '\r');
												if (r)
												{
													const char* b22 = p;
													c = *p++;
													r = (c == '\n');
													if (!r)
													{
														p = b22;
														r = true;
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b21;
										c = *p++;
										r = (c == '#');
										if (r)
										{
											for (;;)
											{
												const char* b23 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b23;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b24 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b24;
															r = true;
														}
													}
												}
												r = !r;
												p = b23;
												if (r)
												{
													c = *p++;
													r = (c != 0);
												}
												if (!r)
												{
													p = b23;
													break;
												}
											}
											r = true;
											if (r)
											{
												const char* b25 = p;
												c = *p++;
												r = (c == '\n');
												if (!r)
												{
													p = b25;
													c = *p++;
													r = (c == '\r');
													if (r)
													{
														const char* b26 = p;
														c = *p++;
														r = (c == '\n');
														if (!r)
														{
															p = b26;
															r = true;
														}
													}
												}
											}
										}
									}
									if (!r)
									{
										p = b21;
										break;
									}
								}
								r = true;
							}
						}
					}
				}
			}
			if (r)
				end[SymbolType_Primary][pBegin] = p;
			else
				fail[SymbolType_Primary].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_1:
		{
			if (fail[SymbolType_Primary_1].count(pBegin))
				return false;
			c = *p++;
			r = (c == '(');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_1][pBegin] = p;
			else
				fail[SymbolType_Primary_1].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_2:
		{
			if (fail[SymbolType_Primary_2].count(pBegin))
				return false;
			c = *p++;
			r = (c == ')');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_2][pBegin] = p;
			else
				fail[SymbolType_Primary_2].insert(pBegin);
			return r;
		}

		case SymbolType_Primary_3:
		{
			if (fail[SymbolType_Primary_3].count(pBegin))
				return false;
			c = *p++;
			r = (c == '.');
			if (r)
			{
				for (;;)
				{
					const char* b = p;
					c = *p++;
					r = (c == ' ');
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '\t');
						if (!r)
						{
							p = b;
							c = *p++;
							r = (c == '\n');
							if (!r)
							{
								p = b;
								c = *p++;
								r = (c == '\r');
								if (r)
								{
									const char* b2 = p;
									c = *p++;
									r = (c == '\n');
									if (!r)
									{
										p = b2;
										r = true;
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						c = *p++;
						r = (c == '#');
						if (r)
						{
							for (;;)
							{
								const char* b3 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b3;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b4 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b4;
											r = true;
										}
									}
								}
								r = !r;
								p = b3;
								if (r)
								{
									c = *p++;
									r = (c != 0);
								}
								if (!r)
								{
									p = b3;
									break;
								}
							}
							r = true;
							if (r)
							{
								const char* b5 = p;
								c = *p++;
								r = (c == '\n');
								if (!r)
								{
									p = b5;
									c = *p++;
									r = (c == '\r');
									if (r)
									{
										const char* b6 = p;
										c = *p++;
										r = (c == '\n');
										if (!r)
										{
											p = b6;
											r = true;
										}
									}
								}
							}
						}
					}
					if (!r)
					{
						p = b;
						break;
					}
				}
				r = true;
			}
			if (r)
				end[SymbolType_Primary_3][pBegin] = p;
			else
				fail[SymbolType_Primary_3].insert(pBegin);
			return r;
		}

		case SymbolType_Range:
		{
			if (fail[SymbolType_Range].count(pBegin))
				return false;
			r = Visit(SymbolType_Char, p, v);
			if (r)
			{
				const char* b = p;
				size_t s = v.size();
				c = *p++;
				r = (c == '-');
				if (r)
				{
					r = Visit(SymbolType_Char, p, v);
				}
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					r = true;
				}
			}
			if (r)
				end[SymbolType_Range][pBegin] = p;
			else
				fail[SymbolType_Range].insert(pBegin);
			return r;
		}

		case SymbolType_Sequence:
		{
			if (fail[SymbolType_Sequence].count(pBegin))
				return false;
			for (;;)
			{
				const char* b = p;
				size_t s = v.size();
				r = Visit(SymbolType_Item, p, v);
				if (!r)
				{
					p = b;
					v.erase(v.begin() + s, v.end());
					break;
				}
			}
			r = true;
			if (r)
				end[SymbolType_Sequence][pBegin] = p;
			else
				fail[SymbolType_Sequence].insert(pBegin);
			return r;
		}

		default:
			assert(false);
			return false;
	}
}

void PEGParser::Parser::Print(std::ostream& _os, PEGParser::SymbolType _type, const char* _pNode, int _tabs, int _maxLineSize)
{
	Symbols children;
	const char* pEnd = _pNode;
	Traverse(_type, pEnd, children);
	//std::cout << children.size() << "\n";
	if (!pEnd)
		throw std::runtime_error(str(boost::format("Parsing Failed for \"%1%\"") % SymbolName(_type)));

	int tabCount = _tabs;
	while (tabCount--)
		_os << "    ";

	_os << SymbolName(_type) << ": \"";

	size_t lineSize = 0;
	for (const char* p = _pNode; p != pEnd; ++p)
	{
		_os << EscapeChar(*p);
		if (++lineSize >= _maxLineSize)
		{
			_os << "...";
			break;
		}
	}

	_os << "\"\n";

	for (Symbols::iterator i = children.begin(), iEnd = children.end(); i != iEnd; ++i)
		Print(_os, i->first, i->second, _tabs + 1, _maxLineSize);
//*
	if (_tabs == 0)
	{
		_os << "Memo Count:\n";
		for (size_t k = 0; k < SymbolTypeCount; ++k)
			_os << boost::format("%1% %|20t|End: %2% %|40t|Fail: %3%\n") % SymbolName(SymbolType(k)) % end[k].size() % fail[k].size();
	}
//*/
}

bool PEGParser::Parser::Visit(PEGParser::SymbolType _type, const char*& _p, PEGParser::Symbols& _v)
{
	const char* pBegin = _p;
	bool r = Parse(_type, _p);
	if (r)
		_v.push_back(Symbol(_type, pBegin));
	return r;
}

std::ostream& PEGParser::operator<<(std::ostream& _os, const PEGParser::Iterator& _i)
{
	if (_i)
	{
		for (const char *p = _i.Begin(), *pEnd = _i.End(); p != pEnd; ++p)
			_os.put(*p);
	}
	return _os;
}

