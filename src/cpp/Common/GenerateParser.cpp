#include "Common.h"
#include "GenerateParser.h"
#include "Grammar.h"

#include <ctemplate/template.h>

class ParserGenerator
{
	std::ostream& mSource;
	const Grammar& mGrammar;
	Tabs mTabs;
	int mNextBacktrackIndex;
	bool mTraverse;
	
public:
	ParserGenerator(std::ostream& _source, const Grammar& _grammar, bool _traverse = false)
	: mSource(_source)
	, mGrammar(_grammar)
	, mTabs(3)
	, mNextBacktrackIndex(1)
	, mTraverse(_traverse)
	{
	}
	
	void Emit(const Expression& expr, int _backtrackIndex)
	{
		switch (expr.GetType())
		{
			case ExpressionType_Empty:
			{
				mSource << mTabs << "r = true;\n";
				break;
			}
				
			case ExpressionType_Choice:
			{
				const Expression::Group& group = expr.GetGroup();
				bool mayUndoVisit = !group.first.isLeaf;
				DefineBacktrack(_backtrackIndex, mayUndoVisit);
				Emit(group.first, _backtrackIndex);
				If("!r");
				OpenBlock();
				Backtrack(_backtrackIndex, mayUndoVisit);
				Emit(group.second, _backtrackIndex);
				CloseBlock();
				break;
			}
				
			case ExpressionType_Sequence:
			{
				const Expression::Group& group = expr.GetGroup();
				Emit(group.first, _backtrackIndex);
				If("r");
				OpenBlock();
				Emit(group.second, -1);
				CloseBlock();
				break;
			}

			case ExpressionType_Not:
			{
				bool traverse = mTraverse;
				mTraverse = false;
				DefineBacktrack(_backtrackIndex, false);
				Emit(expr.GetChild(), _backtrackIndex);
				mSource << mTabs << "r = !r;\n";
				mSource << mTabs << boost::format("p = %1%;\n") % BacktrackVar(_backtrackIndex);
				mTraverse = traverse;
				break;
			}
				
			case ExpressionType_ZeroOrMore:
			{
				_backtrackIndex = -1;
				mSource << mTabs << "for (;;)\n";
				OpenBlock();
				const Expression& child = expr.GetChild();
				bool mayUndoVisit = !child.isLeaf;
				DefineBacktrack(_backtrackIndex, mayUndoVisit);
				Emit(child, _backtrackIndex);
				If("!r");
				OpenBlock();
				Backtrack(_backtrackIndex, mayUndoVisit);
				mSource << mTabs << "break;\n";
				CloseBlock();
				CloseBlock();
				mSource << mTabs << "r = true;\n";
				break;
			}
				
			case ExpressionType_NonTerminal:
			{
				const std::string& nonTerminal = expr.GetNonTerminal();
				const Def& def = *mGrammar.defs.find(nonTerminal);
				const DefValue& defval = def.second;
				if (defval.isNode)
				{
					if (mTraverse)
						mSource << mTabs << boost::format("r = Visit(SymbolType_%1%, p, v);\n") % nonTerminal;
					else
						mSource << mTabs << boost::format("r = Parse(SymbolType_%1%, p);\n") % nonTerminal;
				}
				else
				{
					Emit(defval, _backtrackIndex);
				}
				break;
			}
				
			case ExpressionType_Range:
			{
				Advance(str(boost::format("c >= \'%1%\' && c <= \'%2%\'") % EscapeChar(expr.GetFirst()) % EscapeChar(expr.GetLast())));
				break;
			}
				
			case ExpressionType_Char:
			{
				Advance(str(boost::format("c == \'%1%\'") % EscapeChar(expr.GetChar())));
				break;
			}
				
			case ExpressionType_Dot:
			{
				Advance("c != 0");
				break;
			}
				
			default:
			{
				assert(false);
			}
		}
	}
	
	void Advance(std::string _cond)
	{
		mSource << mTabs << "c = *p++;\n";
		mSource << mTabs << boost::format("r = (%1%);\n") % _cond;
	}
	
	void If(std::string _cond)
	{
		mSource << mTabs << boost::format("if (%1%)\n") % _cond;
	}
	
	void OpenBlock()
	{
		mSource << mTabs << "{\n";
		++mTabs;
	}
	
	void CloseBlock()
	{
		--mTabs;
		mSource << mTabs << "}\n";
	}
	
	static std::string Not(std::string _expr)
	{
		return "!" + _expr;
	}
	
	void DefineBacktrack(int& _backtrackIndex, bool _mayUndoVisit)
	{
		if (_backtrackIndex == -1)
		{
			_backtrackIndex = mNextBacktrackIndex++;
			mSource << mTabs << boost::format("const char* %1% = p;\n") % BacktrackVar(_backtrackIndex);
			if (mTraverse && _mayUndoVisit)
				mSource << mTabs << boost::format("size_t %1% = v.size();\n") % BacktrackVar(_backtrackIndex, 's');
		}
	}
	
	void Backtrack(int _backtrackIndex, bool _undoVisit)
	{
		mSource << mTabs << boost::format("p = %1%;\n") % BacktrackVar(_backtrackIndex);
		if (mTraverse && _undoVisit)
			mSource << mTabs << boost::format("v.erase(v.begin() + %1%, v.end());\n") % BacktrackVar(_backtrackIndex, 's');
	}
	
	static std::string BacktrackVar(int _backtrackIndex, char _prefix = 'b')
	{
		assert(_backtrackIndex != -1);
		if (_backtrackIndex == 1)
			return str(boost::format("%1%") % _prefix);
		else
			return str(boost::format("%1%%2%") % _prefix % _backtrackIndex);
	}
};

static void WriteAutoGenNotice(std::ostream& _os, const std::string& _srcPath)
{
	time_t now = time(NULL);
	char time_buffer[26];

	boost::format fmt(
		"// This file was automatically generated by IPG on %1%"
		"// (from %2%)\n"
		"// DO NOT EDIT!\n");
		
	_os << fmt % ctime_r(&now, time_buffer) % _srcPath;
}

void GenerateParser(std::string _srcPath, std::string _folder, std::string _name, const Grammar& _grammar)
{
	ctemplate::TemplateDictionary dict(_name);
	dict.SetValue("namespace", _name);

	Defs::const_iterator i, iEnd = _grammar.defs.end();
	for (i = _grammar.defs.begin(); i != iEnd; ++i)
	{
		ctemplate::TemplateDictionary* pDef = dict.AddSectionDictionary("def");
		pDef->SetValue("name", i->first);
		
		if (i->second.isNode)
			pDef->ShowSection("isNode");
		else
			pDef->ShowSection("isNotNode");
			
//		if (i->second.isLeaf)
//			pDef->ShowSection("isLeaf");
//		else
//			pDef->ShowSection("isInternal");
		
		std::ostringstream parseCodeStream;
		ParserGenerator parserGenerator(parseCodeStream, _grammar);
		parserGenerator.Emit(i->second, -1);
		
		std::string parseCodeFilename = "parseCode_" + i->first;
		std::string parseCode = parseCodeStream.str();
		ctemplate::StringToTemplateCache(parseCodeFilename, parseCode, ctemplate::STRIP_BLANK_LINES);
		
		pDef->AddIncludeDictionary("parseCode")->SetFilename(parseCodeFilename);
		
		std::ostringstream traverseCodeStream;
		ParserGenerator traverserGenerator(traverseCodeStream, _grammar, true);
		traverserGenerator.Emit(i->second, -1);
		
		std::string traverseCodeFilename = "traverseCode_" + i->first;
		std::string traverseCode = traverseCodeStream.str();
		ctemplate::StringToTemplateCache(traverseCodeFilename, traverseCode, ctemplate::STRIP_BLANK_LINES);

		pDef->AddIncludeDictionary("traverseCode")->SetFilename(traverseCodeFilename);
	}

	std::string headerText;
	if (!ctemplate::ExpandTemplate("Parser.h.tpl", ctemplate::STRIP_BLANK_LINES, &dict, &headerText))
		throw std::runtime_error("CTemplate Parser.h.tpl expansion failed!");
	
	std::ofstream headerFile;
	headerFile.exceptions(std::ofstream::failbit | std::ofstream::badbit);
	headerFile.open((_folder + _name + ".h").c_str());
	WriteAutoGenNotice(headerFile, _srcPath);
	headerFile << boost::format("#ifndef %1%_H\n#define %1%_H\n\n") % boost::to_upper_copy(_name);
	headerFile << headerText;
	headerFile << "\n#endif\n";
	
	dict.SetValue("header", headerText);

	std::string sourceText;
	if (!ctemplate::ExpandTemplate("Parser.cpp.tpl", ctemplate::STRIP_BLANK_LINES, &dict, &sourceText))
		throw std::runtime_error("CTemplate Parser.cpp.tpl expansion failed!");
	
	std::ofstream sourceFile;
	sourceFile.exceptions(std::ofstream::failbit | std::ofstream::badbit);
	std::string sourcePath = _folder + _name + ".cpp";
	sourceFile.open(sourcePath.c_str());
	WriteAutoGenNotice(sourceFile, _srcPath);
	sourceFile << sourceText;	
}
