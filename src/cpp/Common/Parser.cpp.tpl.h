// This file automatically generated by template-converter:
//    /usr/local/bin/template-converter Parser.cpp.tpl /Users/alexk7/ipg/build/xcode/../../src/tpl/Parser.cpp.tpl /Users/alexk7/ipg/build/xcode/../../src/cpp/Common/Parser.cpp.tpl.h
//
// DO NOT EDIT!

#ifndef PARSER_CPP_TPL_H_
#define PARSER_CPP_TPL_H_

#include <string>

const std::string Parser_cpp_tpl (
"// This file was automatically generated by IPG\n"
"// DO NOT EDIT!\n"
"#include \"{{name}}.h\"{{BI_NEWLINE}}\n"
"\n"
"using namespace {{name}};{{BI_NEWLINE}}\n"
"\n"
"namespace\n"
"{\n"
"	typedef PTNodeTypeToPtr::value_type MemoEntry;\n"
"	typedef std::pair<PTNodeTypeToPtr::iterator, bool> MemoInsertResult;{{BI_NEWLINE}}\n"
"	\n"
"	struct Private\n"
"	{{{#def}}{{BI_NEWLINE}}		static Node* Parse_{{name}}(Node* p0)\n"
"		{\n"
"			{{#isMemoized}}\n"
"			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_{{name}}, 0));\n"
"			if (!r.second)\n"
"				return r.first->second;\n"
"			{{/isMemoized}}\n"
"			{{>parseCode}}\n"
"			{{#isMemoized}}\n"
"			r.first->second = p{{parseResultIndex}};\n"
"			{{/isMemoized}}\n"
"			return p{{parseResultIndex}};\n"
"		}\n"
"		{{/def}}\n"
"		\n"
"		{{#def}}{{BI_NEWLINE}}		static Node* Traverse_{{name}}(Node* p0, PTNodeChildren& v)\n"
"		{\n"
"			Node* p1 = Parse_{{name}}(p0);\n"
"			if (!p1)\n"
"				return 0;\n"
"			{{>traverseCode}}\n"
"			return p1;\n"
"		}\n"
"		{{/def}}\n"
"	};\n"
"}{{BI_NEWLINE}}\n"
"\n"
"namespace {{name}}\n"
"{\n"
"	Node* Parse(PTNodeType _type, Node* _symbol)\n"
"	{\n"
"		switch (_type)\n"
"		{\n"
"			{{#def}}\n"
"			case PTNodeType_{{name}}: return Private::Parse_{{name}}(_symbol);\n"
"			{{/def}}\n"
"		}\n"
"		return 0;\n"
"	}{{BI_NEWLINE}}\n"
"	\n"
"	Node* Traverse(PTNodeType _type, Node* _symbol, PTNodeChildren& _children)\n"
"	{\n"
"		switch (_type)\n"
"		{\n"
"			{{#def}}\n"
"			case PTNodeType_{{name}}: return Private::Traverse_{{name}}(_symbol, _children);\n"
"			{{/def}}\n"
"		}\n"
"		return 0;\n"
"	}\n"
"}\n"
);

#endif /* PARSER_CPP_TPL_H_ */
