// This file was automatically generated by IPG
// DO NOT EDIT!
#include "{{name}}.h"{{BI_NEWLINE}}

using namespace {{name}};{{BI_NEWLINE}}

namespace
{
	PTNode* ParseRange(char _rangeBegin, char _rangeEnd, PTNode* _symbol)
	{
		if (_symbol->value < _rangeBegin)
			return 0;
		if (_symbol->value > _rangeEnd)
			return 0;
		return ++_symbol;
	}{{BI_NEWLINE}}
	
	PTNode* ParseChar(char _char, PTNode* _symbol)
	{
		if (_symbol->value != _char)
			return 0;
		return ++_symbol;
	}{{BI_NEWLINE}}
	
	PTNode* ParseAnyChar(PTNode* _symbol)
	{
		if (_symbol->value == 0)
			return 0;
		return ++_symbol;
	}{{BI_NEWLINE}}
	
	struct Memo
	{
		Memo(PTNode* _symbol, PTNodeType _type)
		{
			std::pair<PTNodeTypeToPtr::iterator, bool> insertResult	=
				_symbol->end.insert(PTNodeTypeToPtr::value_type(_type, 0));{{BI_NEWLINE}}
				
			ppNode = &insertResult.first->second;
			isValid = !insertResult.second;
		}{{BI_NEWLINE}}
		
		PTNode** ppNode;
		bool isValid;
	};{{BI_NEWLINE}}
	
	PTNode* Visit(PTNode* _symbol, PTNodeType _type, PTNodeVisitor& _visitor)
	{
		PTNode* end = _symbol->end[_type];
		if (end)
			_visitor(_symbol, _type);
		return end;
	}{{BI_NEWLINE}}
	
	struct Parse
	{{{#def}}{{BI_NEWLINE}}		static PTNode* {{name}}(PTNode* p0)
		{
			{{#isMemoized}}
			Memo memo(p0, PTNodeType_{{name}});
			if (memo.isValid)
				return *memo.ppNode;
			{{/isMemoized}}
			{{>parseCode}}
			{{#isMemoized}}
			*memo.ppNode = p{{parseResultIndex}};
			{{/isMemoized}}
			return p{{parseResultIndex}};
		}
		{{/def}}
	};{{BI_NEWLINE}}
	
	struct Traverse
	{{{#def}}{{BI_NEWLINE}}		static PTNode* {{name}}(PTNode* p0, PTNodeVisitor& v)
		{
			if (!Parse::{{name}}(p0))
				return 0;
			{{>traverseCode}}
			return p{{traverseResultIndex}};
		}
		{{/def}}
	};
}{{BI_NEWLINE}}

namespace {{name}}
{
	PTNode* Parse(PTNodeType _type, PTNode* _symbol)
	{
		switch (_type)
		{
			{{#def}}
			case PTNodeType_{{name}}: return Parse::{{name}}(_symbol);
			{{/def}}
		}
		return 0;
	}{{BI_NEWLINE}}
	
	PTNode* Traverse(PTNodeType _type, PTNode* _symbol, PTNodeVisitor& _visitor)
	{
		switch (_type)
		{
			{{#def}}
			case PTNodeType_{{name}}: return Traverse::{{name}}(_symbol, _visitor);
			{{/def}}
		}
		return 0;
	}
}
