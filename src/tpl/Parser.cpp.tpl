// This file was automatically generated by IPG
// DO NOT EDIT!
#include "{{name}}.h"{{BI_NEWLINE}}

using namespace {{name}};{{BI_NEWLINE}}

namespace
{
	typedef PTNodeTypeToPtr::value_type MemoEntry;
	typedef std::pair<PTNodeTypeToPtr::iterator, bool> MemoInsertResult;{{BI_NEWLINE}}
	
	struct Private
	{{{#def}}{{BI_NEWLINE}}		static Node* Parse_{{name}}(Node* p0)
		{
			{{#isMemoized}}
			MemoInsertResult r = p0->end.insert(MemoEntry(PTNodeType_{{name}}, 0));
			if (!r.second)
				return r.first->second;
			{{/isMemoized}}
			{{>parseCode}}
			{{#isMemoized}}
			r.first->second = p{{parseResultIndex}};
			{{/isMemoized}}
			return p{{parseResultIndex}};
		}
		{{/def}}
		
		{{#def}}{{BI_NEWLINE}}		static Node* Traverse_{{name}}(Node* p0, PTNodeChildren& v)
		{
			Node* p1 = Parse_{{name}}(p0);
			if (!p1)
				return 0;
			{{>traverseCode}}
			return p1;
		}
		{{/def}}
	};
}{{BI_NEWLINE}}

namespace {{name}}
{
	Node* Parse(PTNodeType _type, Node* _symbol)
	{
		switch (_type)
		{
			{{#def}}
			case PTNodeType_{{name}}: return Private::Parse_{{name}}(_symbol);
			{{/def}}
		}
		return 0;
	}{{BI_NEWLINE}}
	
	Node* Traverse(PTNodeType _type, Node* _symbol, PTNodeChildren& _children)
	{
		switch (_type)
		{
			{{#def}}
			case PTNodeType_{{name}}: return Private::Traverse_{{name}}(_symbol, _children);
			{{/def}}
		}
		return 0;
	}
}
